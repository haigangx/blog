### C++

<table>
<tr>
  <td align="center">C</td>
  <td align="center">C++</td>
</tr>
<tr>
  <td><ul>
    <li><a href=""></a></li>
    <li><a href=""></a></li>
    <li><a href=""></a></li>
    <li><a href=""></a></li>
  </ul></td>
  <td>
    <li><a href=""></a></li>
    <li><a href=""></a></li>
    <li><a href=""></a></li>
    <li><a href=""></a></li>
  </td>
</tr>
<tr>
  <td align="center">C++11</td>
  <td align="center">C++11~</td>
</tr>
<tr>
  <td>
    <li><a href=""></a></li>
    <li><a href=""></a></li>
  </td>
  <td>
    <li><a href=""></a></li>
    <li><a href=""></a></li>
  </td>
</tr>
</table>

#### STL

<table>
<tr>
    <td align="center" colspan="8">STL技法</td>
</tr>
<tr>
    <td><a href="content/stl/迭代器.md">迭代器</td>
    <td><a href="content/stl/空间配置器.md">空间配置器</td>
    <td><a href="content/stl/仿函数.md">仿函数</td>
    <td><a href="content/stl/配接器.md">配接器</td>
    <td colspan="4"></td>
</tr>
<tr>
    <td align="center" colspan="8">序列式容器</td>
</tr>
<tr>
    <td><a href="content/stl/vector.md">vector</td>
    <td><a href="content/stl/list.md">list</td>
    <td><a href="content/stl/deque.md">deque</td>
    <td><a href="content/stl/stack.md">stack</td>
    <td><a href="content/stl/queue.md">queue</td>
    <td><a href="content/stl/heap.md">heap</td>
    <td><a href="content/stl/priority_queue.md">priority_queue</td>
    <td><a href="content/stl/slist.md">slist</td>
</tr>
<tr>
    <td align="center" colspan="8">关联式容器</td>
</tr>
<tr>
    <td><a href="content/stl/RB-Tree.md">RB-Tree</td>
    <td><a href="content/stl/hashtable.md">hashtable</td>
    <td><a href="content/stl/set.md">set</td>
    <td><a href="content/stl/map.md">map</td>
    <td colspan="4"></td>
</tr>
<tr>
    <td align="center" colspan="8">算法</td>
</tr>
<tr>
    <td><a href="content/stl/sort.md">sort</td>
    <td colspan="7"></td>
</tr>
<tr>
    <td align="center" colspan="8">辅助工具</td>
</tr>
<tr>
    <td><a href="content/stl/pair.md">pair</td>
    <td colspan="7"></td>
</tr>
<tr>
    <td align="center" colspan="8">总结</td>
</tr>
<tr>
    <td colspan="2"><a href="content/stl/迭代器失效.md">迭代器失效总结</td>
    <td colspan="6"></td>
</tr>
</table>

#### 设计模式

<table>
<tr>
    <td><a href="content/design_pattern/singleton.md" title="单例模式[创建型模式]">Singleton</a></td>
    <td><a href="content/design_pattern/factory-method.md" title="工厂方法[创建型模式]">FactoryMethod</a></td>
    <td><a href="content/design_pattern/abstract-factory.md" title="抽象工厂[创建型模式]">AbstractFactory</a></td>
    <td><a href="content/design_pattern/builder.md" title="生成器[创建型模式]">Builder</a></td>
    <td><a href="content/design_pattern/prototype.md" title="原型[创建型模式]">Prototype</a></td>
    <td><a href="content/design_pattern/adapter.md" title="适配器[结构型模式]">Adapter</a></td>
</tr>
<tr>
    <td><a href="content/design_pattern/bridge.md" title="桥接[结构型模式]">Bridge</a></td>
    <td><a href="content/design_pattern/composite.md" title="组合[结构型模式]">Composite</a></td>
    <td><a href="content/design_pattern/decorator.md" title="装饰[结构型模式]">Decorator</a></td>
    <td><a href="content/design_pattern/facade.md" title="外观[结构型模式]">Facade</a></td>
    <td><a href="content/design_pattern/fly-weight.md" title="享元[结构型模式]">FlyWeight</a></td>
    <td><a href="content/design_pattern/proxy.md" title="代理[结构型模式]">Proxy</a></td>
</tr>
<tr>
    <td><a href="content/design_pattern/chain-of-responsibility.md" title="责任链[行为模式]">ChainOfResponsibility</a></td>
    <td><a href="content/design_pattern/command.md" title="命令[行为模式]">Command</a></td>
    <td><a href="content/design_pattern/interpreter.md" title="解释器[行为模式]">Interpreter</a></td>
    <td><a href="content/design_pattern/iterpreter.md" title="迭代器[行为模式]">Iterator</a></td>
    <td><a href="content/design_pattern/mediator.md" title="中介者[行为模式]">Mediator</a></td>
    <td><a href="content/design_pattern/memento.md" title="备忘录[行为模式]">Mementor</a></td>
</tr>
<tr>
    <td><a href="content/design_pattern/observer.md" title="观察者[行为模式]">Observer</a></td>
    <td><a href="content/design_pattern/state.md" title="状态[行为模式]">State</a></td>
    <td><a href="content/design_pattern/strategy.md" title="策略[行为模式]">Strategy</a></td>
    <td><a href="content/design_pattern/template-method.md" title="模板方法[行为模式]">Strategy</a></td>
    <td><a href="content/design_pattern/visitor.md" title="访问者[行为模式]">Visitor</a></td>
    <td colspan="1"></td>
</tr>
</table>

#### 《Effective C++》

<table>
<tr>
    <td><a href="content/effective_cpp/01.md" title="视C++为一个语言联邦">01：视C++为一个语言联邦</td>
    <td><a href="content/effective_cpp/02.md" title="尽量以const, enum, inline替换#define">02：尽量以const, enum, inline替换#define</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/03.md" title="尽可能使用const">03：尽可能使用const</td>
    <td><a href="content/effective_cpp/04.md" title="确定对象被使用前已被初始化">04：确定对象被使用前已被初始化</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/05.md" title="">05：了解C++默默编写并调用哪些函数</td>
    <td><a href="content/effective_cpp/06.md" title="">06：若不想使用编译器自动生成的函数，就该明确拒绝</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/07.md" title="">07：为多态基类声明virtual析构函数</td>
    <td><a href="content/effective_cpp/08.md" title="">08：别让异常逃离析构函数</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/09.md" title="">09：绝不在构造和析构过程中调用virtual函数</td>
    <td><a href="content/effective_cpp/10.md" title="">10：令operator=返回一个reference to *this</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/11.md" title="">11：在operator=中处理自我赋值</td>
    <td><a href="content/effective_cpp/12.md" title="">12：复制对象时勿忘其每一个成分</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/13.md" title="">13：以对象管理资源</td>
    <td><a href="content/effective_cpp/14.md" title="">14：在资源管理类中小心copying行为</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/15.md" title="">15：在资源管理类中提供对原始资源的访问</td>
    <td><a href="content/effective_cpp/16.md" title="">16：成对使用new和delete时要采取相同形式</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/17.md" title="">17：以独立语句将newed对象置入智能指针</td>
    <td><a href="content/effective_cpp/18.md" title="">18：让接口容易被正确使用，不易被误用</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/19.md" title="">19：设计class犹如设计type</td>
    <td><a href="content/effective_cpp/20.md" title="">20：宁以pass-by-reference-to-const替换pass-by-value</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/21.md" title="">21：必须返回对象时，别妄想返回其reference</td>
    <td><a href="content/effective_cpp/22.md" title="">22：将成员变量声明为private</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/23.md" title="">23：宁以non-member、non-friend替换member函数</td>
    <td><a href="content/effective_cpp/24.md" title="">24：若所有参数皆需类型转换，请为此采用non-member函数</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/25.md" title="">25：考虑写出一个不抛异常的swap函数</td>
    <td><a href="content/effective_cpp/26.md" title="">26：尽可能延后变量定义式的出现时间</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/27.md" title="">27：尽量少做转型动作</td>
    <td><a href="content/effective_cpp/28.md" title="">28：避免返回handles指向对象内部成分</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/29.md" title="">29：为异常安全而努力是值得的</td>
    <td><a href="content/effective_cpp/30.md" title="">30：透彻了解inlining的里里外外</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/31.md" title="">31：将文件间的编译依存关系降至最低</td>
    <td><a href="content/effective_cpp/32.md" title="">32：确定你的public继承塑膜出is-a关系</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/33.md" title="">33：避免遮掩继承而来的名称</td>
    <td><a href="content/effective_cpp/34.md" title="">34：区分接口继承和实现继承</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/35.md" title="">35：考虑virtual函数以外的其他选择</td>
    <td><a href="content/effective_cpp/36.md" title="">36：绝不重新定义继承而来的non-virtual函数</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/37.md" title="">37：绝不重新定义继承而来的缺省参数值</td>
    <td><a href="content/effective_cpp/38.md" title="">38：通过复合塑膜出has-a或"根据某物实现出"</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/39.md" title="">39：明智而审慎的使用private继承</td>
    <td><a href="content/effective_cpp/40.md" title="">40：明智而审慎的使用多重继承</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/41.md" title="">41：了解隐式接口和编译器多态</td>
    <td><a href="content/effective_cpp/42.md" title="">42：了解typename的双重意义</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/43.md" title="">43：学习处理模板化基类内的名称</td>
    <td><a href="content/effective_cpp/44.md" title="">44：将与参数无关的代码抽离templates</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/45.md" title="">45；运用成员函数模板接受所有兼容类型</td>
    <td><a href="content/effective_cpp/46.md" title="">46：需要类型转换时请为模板定义非成员函数</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/47.md" title="">47：请使用traits classes表现类型信息</td>
    <td><a href="content/effective_cpp/48.md" title="">48：认识template元编程</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/49.md" title="">49：了解new-handler的行为</td>
    <td><a href="content/effective_cpp/50.md" title="">50：了解new和delete的合理替换时机</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/51.md" title="">51：编写new和delete时固守常规</td>
    <td><a href="content/effective_cpp/52.md" title="">52：写了placement new也要写placement delete</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/53.md" title="">53：不要轻忽编译器的警告</td>
    <td><a href="content/effective_cpp/54.md" title="">54：让自己熟悉包括TR1在内的标准程序库</td>
</tr>
<tr>
    <td><a href="content/effective_cpp/55.md" title="">55：让自己熟悉Boost</td>
    <td colspan="1"></td>
</tr>
</table>

### Linux

#### 命令

<table>
<tr>
    <td><a href="content/linux_base/command/shell_keybind.md">shell快捷键</td>
    <td><a href="content/linux_base/command/summary.md">常用命令</td>
    <td><a href="content/linux_base/command/awk.md" title="">awk</td>
    <td><a href="content/linux_base/command/curl.md" title="">curl</td>
    <td><a href="content/linux_base/command/find.md" title="">find</td>
    <td><a href="content/linux_base/command/ifstat.md" title="">ifstat</td>
    <td><a href="content/linux_base/command/mpstat.md" title="">mpstat</td>
    <td><a href="content/linux_base/command/nc.md" title="">nc</td>
    <td><a href="content/linux_base/command/netstat.md" title="">netstat</td>
</tr>
<tr>
    <td><a href="content/linux_base/command/vmstat.md" title="">vmstat</td>
    <td><a href="content/linux_base/command/top-htop.md" title="">top-htop</td>
    <td><a href="content/linux_base/command/strace.md" title="">strace</td>
    <td><a href="content/linux_base/command/ltrace.md" title="">ltrace</td>
    <td><a href="content/linux_base/command/pstack.md" title="">pstack</td>
    <td><a href="content/linux_base/command/valgrind.md" title="">valgrind</td>
    <td><a href="content/linux_base/command/tcpdump.md" title="">tcpdump</td>
    <td><a href="content/linux_base/command/grep.md" title="">grep</td>
    <td><a href="content/linux_base/command/tar.md" title="">tar</td>
</tr>
<tr>
    <td><a href="content/linux_base/command/lsof.md" title="">lsof</td>
    <td><a href="content/linux_base/command/sed.md" title="">sed</td>
    <td><a href="content/linux_base/command/scp.md" title="">scp</td>
    <td><a href="content/linux_base/command/ssh.md" title="">ssh</td>
    <td><a href="content/linux_base/command/telnet.md" title="">telnet</td>
    <td><a href="content/linux_base/command/gcc.md" title="">gcc</td>
    <td><a href="content/linux_base/command/wc.md" title="">wc</td>
    <td><a href="content/linux_base/command/expr.md" title="">expr</td>
    <td colspan="1"></td>
</tr>
</table>

#### linux基础

<table>
<tr>
  <td><ul>
  <li><a href="">linux文件系统详解</a></li>
  <li><a href="">进程和线程的区别</li>
  <li><a href="">linux下调试方法总结</li>
  </ul></td>
  <td><ul>
  <li><a href="">linux中的零拷贝技术</a></li>
  <li><a href="">linux后台任务的运行关闭查看</a></li>
  </ul></td>
</tr>
</table>

### 工具学习

<table>
<tr>
  <td><a href="content/tools/bash.md">Bash</td>
  <td><a href="content/tools/gdb.md">GDB</td>
  <td><a href="content/tools/Markdown.md">Markdown</td>
  <td><a href="content/tools/tmux.md">tmux</td>
  <td><a href="content/tools/vscode.md">vscode</td>
  <td><a href="content/tools/zsh.md">zsh</td>
  <td><a href="content/tools/cmake.md">CMake</td>
  <td><a href="content/tools/docker.md">docker</td>
<tr>
</tr>
  <td><a href="content/tools/git.md">Git</td>
  <td><a href="content/tools/regular_expression.md">正则表达式</td>
  <td><a href="content/tools/vim.md">vim</td>
  <td><a href="content/tools/wireshark.md">WireShark</td>
  <td colspan="4"></td>
</tr>
</table>

