# 两种高效的事件处理模式——Reactor模式和Proactor模式

图


服务器程序通常需要处理三类事件：I/O事件、信号和定时事件，后续将依次具体讨论这3种类型的事件，从整体上来说有两种高效的事件处理模式：Reactor和Proactor

一般来说，同步I/O模型常用于实现Reactor模式，异步I/O模型用于实现Proactor模式，不过我们可以通过使用同步I/O方式模拟出Proactor模式

1、Reactor模式

Reactor：要求主线程(I/O处理单元)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(逻辑单元)处理，除此之外，主线程不做任何其他实质性工作，读写数据，接收新连接，以及处理客户请求均在工作线程中完成

使用同步I/O模型(epoll_wait为例)实现Reactor模式的工作流程如下：

- 1、主线程往epoll内核事件表中注册socket上的读就绪事件
- 2、主线程调用epoll_wait等待socket上有数据可读
- 3、当socket上有数据可读时，epoll_wait通知主线程，主线程则将socket可读事件放入请求队列
- 4、睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件
- 5、主线程调用epoll_wait等待socket可写
- 6、当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列
- 7、睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果

Reactor的工作流程如下图：


上图中，工作线程从请求队列中取出事件后，将根据事件的类型来决定如果处理它：
    
    对于可读事件，执行读数据和处理请求的操作
    
    对于可写事件，执行写数据操作

因此，在图示的Reactor模式中，没有必要区分“读工作线程”和“写工作线程”

2、Proactor模式

与Reactor模式不同，Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑

使用异步I/O模型(aio_read和aio_write为例)实现的Proactor模式的工作流程是：

- 1、主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序(以信号为例，sigevent)
- 2、主线程继续处理其他逻辑
- 3、当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用
- 4、应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序(信号为例)
- 5、主线程继续处理其他逻辑
- 6、当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序已经发送完毕
- 7、应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket

Proactor模式的工作流程如下图：

连接socket上的读写事件是通过aio_read/aio_write向内核注册的，因此内核将通过信号来向应用程序报告连接socket上的读写事件。所以主线程中的epoll_wait调用仅能用来检测监听socket上的连接请求事件，而不能用来检测连接socket上的读写事件

3、模拟Proactor模式

可以使用同步I/O方式模拟出Proactor模式。其原理是：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。

使用同步I/O模型(epoll_wait为例)模拟出的Proactor模式的工作流程如下：

- 1、主线程往epoll内核事件表中注册socket上的读就绪事件
- 2、主线程调用epoll_wait等待socket上有数据可读
- 3、当socket有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入到请求队列
- 4、睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件
- 5、主线程调用epoll_wait等待socket可写
- 6、当socket可写时，epoll_wait通知主线程，主线程往socket上写入服务器处理客户请求的结果

同步I/O模型模拟出的Proactor模式工作流程如下图：

