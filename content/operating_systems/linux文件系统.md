# Linux 文件系统

<!-- TOC -->

- [一、文件系统特性](#一文件系统特性)
    - [1. 索引式文件系统](#1-索引式文件系统)
    - [2. 顺序式文件系统](#2-顺序式文件系统)
- [二、Linux 的 ext2 文件系统](#二linux-的-ext2-文件系统)
    - [1. 超级块(Super Block)](#1-超级块super-block)
    - [2. 块组描述符表(GDT, Group Descriptor Table)](#2-块组描述符表gdt-group-descriptor-table)
    - [4. 块位图(Block Bitmap)](#4-块位图block-bitmap)
    - [5. inode 位图(inode Bitmap)](#5-inode-位图inode-bitmap)
    - [6. inode 表(inode Table)](#6-inode-表inode-table)
    - [7. 数据块(Data Block)](#7-数据块data-block)
- [三、使用 dumpe2fs 观察 Linux 文件系统](#三使用-dumpe2fs-观察-linux-文件系统)

<!-- /TOC -->

## 一、文件系统特性

我们都知道磁盘分区完毕后要进行 **格式化(format)** 后操作系统才能够使用这个分区。 为什么需要进行格式化呢？其实格式化即是将这个分区初始化为当前操作系统所能识别的文件系统格式

文件系统除了管理文件实际内容外，还需要管理很多文件属性，如：文件权限(rwx)与文件属性（拥有者、群组、时间）等，文件系统通常会将这两部分数据存放在不同的区块：

- 权限与属性放置到 inode 中
- 实际数据则放置到 datablock 区块中 

当然，还有许多其他区块用来记录文件系统的其他信息，这个后面再说明

每个 inode 与 block 都有编号，这两个数据的意义可以简略说明如下：

- inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block 号码；
- block：实际记录文件的内容，若文件太大时，会占用多个 block 。

### 1. 索引式文件系统

由于每个 inode 与 block 都有编号，而每个文件都会占用一个 inode ，inode 内则有文件数据放置的 block 号码。 因此，如果能够找到文件的 inode 的话，就能直到这个文件所放置数据的 block 号码， 就能读出该文件的实际数据了。

这是个比较有效率的作法，因为磁盘就能够在短时间内读取出文件的全部数据

将 inode 与 block 区块用图解来说明一下，如下图所示，文件系统先格式化出 inode 与 block 的区块，假设某一个文件的属性与权限数据是放置到 inode 4 号(下图较小方格内)，而这个 inode 记录了文件数据的实际放置点为 2, 7, 13, 15 这四个 block 号码，此时我们的操作系统就能够据此来排列磁盘的阅读顺序，可以一口气将四个 block 内容读出来！ 那么数据的读取就如同下图中的箭头所指定的模样了。

<div align="center"><image src="../doc/索引式文件系统图示.jpg"></image></div>

这种数据存取的方式为 **索引式文件系统(indexed allocation)**

### 2. 顺序式文件系统

与索引式相对于的是 **顺序式文件系统**，以 FAT 文件系统为例：FAT 这种格式的文件系统并没有 inode 存在，所以 FAT 没有办法将这个文件的所有 block 在一开始就读取出来。每个 block 号码都记录在前一个 block 当中， 他的读取方式有点像底下这样：

<div align="center"><image src="../doc/顺序式文件系统.jpg"></image></div>

上图中我们假设文件的数据依序写入 1->7->4->15 号这四个 block 号码中， 但这个文件系统没有办法一口气就知道四个 block 的号码，他得要一个一个的将 block 读出后，才会知道下一个 block 在何处。 如果同一个文件数据写入的 block 分散的太过厉害时，则我们的磁盘读取头将无法在磁盘转一圈就读到所有的数据， 因此磁盘就会多转好几圈才能完整的读取到这个文件的内容！

> 有些文件系统需要碎片整理的原因就是文件写入的 block 太过于离散了，此时文件读取的效能将会变的很差。 这个时候可以透过碎片整理将同一个文件所属的 blocks 汇整在一起，使数据读写更容易 


## 二、Linux 的 ext2 文件系统


以 ext2 文件系统说明 Linux 文件系统的结构：

<div align="center"><image src="../doc/ext2文件系统.png"></image></div>

上图是一个磁盘分区格式化为 ext2 文件系统后的存储布局：

其中 **启动块（Boot Block）** 的大小是确定的，就是1KB，启动块是由PC标准规定的，用来存储磁盘分区信息和启动信息，任何文件系统都不能使用启动块，启动块之后才是ext2文件系统的开始。

ext2文件系统将整个分区划成若干个同样大小的块组（Block Group），每个块组都由以下部分组成：


### 1. 超级块(Super Block)

Superblock 是记录整个 filesystem 相关信息的地方， 没有 Superblock ，就没有这个 filesystem 了。其记录的信息主要有：

- block 与 inode 的总量
- 未使用与已使用的 inode / block 数量
- block 与 inode 的大小 (block 为 1, 2, 4K，inode 为 128 bytes)
- filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 (fsck) 的时间等文件系统的相关信息
- 一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit 为 1

一般来说， superblock 的大小为 1024bytes。Superblock 是非常重要的，每个 block group 都可能含有 superblock，但是只有第一个 block group 中的 superblock 会使用，其他 block group 的 superblock 主要是做为第一个 block group 内 superblock 的备份，用于 superblock 被损坏后的修复

### 2. 块组描述符表(GDT, Group Descriptor Table)

由很多块组描述符组成，整个分区分成多少个块组就对应有多少个块组描述符。每个块组描述符（Group Descriptor）存储一个块组的描述信息，例如在这个块组中从哪里开始是inode表，从哪里开始是数据块，空闲的 inode和数据块还有多少个等等。

和超级块类似，块组描述符表在每个块组的开头也都有一份拷贝，这些信息是非常重要的，一旦超级块意外损坏就会丢失整个分区的数据，一旦块组描述符意外损坏就会丢失整个块组的数据，因此它们都有多份拷贝。通常内核只用到第0个块组中的拷贝。

当执行 e2fsck 检查文件系统一致性时，第 0 个块组中的超级块和块组描述符表就会拷贝到其它块组，这样当第 0 个块组的开头意外损坏时就可以用其它拷贝来恢复，从而减少损失。

### 4. 块位图(Block Bitmap)

Block Bitmap 使用位图描述整个快组中哪些块已用哪些块空闲，其中的每个 bit 代表本块组中一个块，bit 为 1 表示该块已用，为 0 表示该块空闲可用

> `df` 命令使用块位图统计磁盘的已用空间，因此非常快，而 `du` 命令通过遍历所有文件来统计磁盘的使用空间，因此非常慢

在格式化一个分区时究竟会划出多少个块组呢？

主要的限制在于 **块位图本身必须只占一个 block**。用 mke2fs 格式化时默认块大小是 1024 字节，可以用 -b 参数指定块大小，现在设块大小指定为 b 字节，那么一个块可以有 8b 个bit，这样大小的一个块位图就可以表示 8b 个块的占用情况，因此一个块组最多可以有 8b 个块，如果整个分区有 s 个块，那么就可以有 s/(8b) 个块组。格式化时可以用 -g 参数指定一个块组有多少个块，但是通常不需要手动指定，mke2fs工具会计算出最优的数值

### 5. inode 位图(inode Bitmap)

和块位图类似，本身仅占一个 block，其中每个 bit 表示一个 inode 是否空闲可用


### 6. inode 表(inode Table)

inode 用来记录文件属性以及该文件实际数据放置的 block，具体包括以下内容：

- 该文件的存取模式 (read/write/excute)
- 该文件的拥有者与群组 (owner/group)
- 该文件的容量
- 该文件创建或状态改变的时间 (ctime)
- 最近一次的读取时间 (atime)
- 最近修改的时间 (mtime)
- 定义文件特性的旗标 (flag)，如 SetUID...
- 该文件真正内容的指向 (pointer)

inode 的数量与大小在格式化时已经固定，除此之外：

- 每个 inode 大小均固定为 128 bytes
- 每个文件都仅会占用一个 inode，因此文件系统能够创建的文件数量与 inode 的数量有关
- 系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与用户是否符合，若符合才能够开始实际读取 block 的内容

分析一下 inode/block 与文件大小的关系：

inode 要记录的数据非常多，但偏偏又只有 128bytes 而已， 而 inode 记录一个 block 号码要花掉 4byte ，假设我一个文件有 400MB 且每个 block 为 4K 时， 那么至少也要十万笔 block 号码的记录！inode 哪有这么多可记录的信息？

为此 ext2 系统将 inode 记录 block 号码的区域定义为12个直接，一个间接, 一个双间接与一个三间接记录区。如下图所示：

<div align="center"><image src="../doc/inode结构示意图.jpg"></image></div>

上图最左边为 inode 本身 (128 bytes)，里面有 12 个直接指向 block 号码的对照，这 12 笔记录就能够直接取得 block 号码啦！ 所谓的间接就是再拿一个 block 来当作记录 block 号码的记录区，如果文件太大时， 就会使用间接的 block 来记录编号。如上图中间接只是拿一个 block 来记录额外的号码而已。 同理，如果文件持续长大，那么就会利用所谓的双间接，第一个 block 仅再指出下一个记录编号的 block 在哪里， 实际记录的在第二个 block 当中。依此类推，三间接就是利用第三层 block 来记录编号！

这样子 inode 能够指定多少个 block 呢？我们以较小的 1K block 来说明好了，可以指定的情况如下：

- 12 个直接指向： 12*1K=12K
  由于是直接指向，所以总共可记录 12 笔记录，因此总额大小为如上所示；

- 间接： 256*1K=256K
  每笔 block 号码的记录会花去 4bytes，因此 1K 的大小能够记录 256 笔记录，因此一个间接可以记录的文件大小如上；

- 双间接： 256*256*1K=2562K
  第一层 block 会指定 256 个第二层，每个第二层可以指定 256 个号码，因此总额大小如上；

- 三间接： 256*256*256*1K=2563K
  第一层 block 会指定 256 个第二层，每个第二层可以指定 256 个第三层，每个第三层可以指定 256 个号码，因此总额大小如上；

总额：将直接、间接、双间接、三间接加总，得到 12 + 256 + 256*256 + 256*256*256 (K) = 16GB

此时我们知道当文件系统将 block 格式化为 1K 大小时，能够容纳的最大文件为 16GB，比较一下文件系统限制表的结果可发现是一致的！但这个方法不能用在 2K 及 4K block 大小的计算中， 因为大于 2K 的 block 将会受到 Ext2 文件系统本身的限制，所以计算的结果会不太符合之故。

### 7. 数据块(Data Block)

data block 是用来放置文件内容数据的地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种，且在初始化时就已经固定了，每个 block 都有编号，以方便 inode 的记录 

> 可以使用 `mke2fs` 命令的 `-b` 选项设定块大小为 1k、2k、4k 大小

由于 block 大小的差异，会导致该文件系统能够支持的最大磁盘容量与最大单一文件容量并不相同。 因为 block 大小而产生的 Ext2 文件系统限制如下：

| Block 大小 | 1 KB | 2 KB | 4 KB |
| --- | --- | --- | --- |
| 最大单一文件限制 | 16 GB | 256 GB | 2 TB |
| 最大文件系统总容量 | 2 TB | 8 TB | 16 TB |

ext2 文件系统的 block 有以下限制：

- 原则上，block 的大小与数量在格式化完就不能够再改变了(除非重新格式化)
- 每个 block 内最多只能够放置一个文件的数据
  - 如果文件大于 block 的大小，则一个文件会占用多个 block 数量；
  - 若文件小于 block ，则该 block 的剩余容量就不能够再被使用了(磁盘空间会浪费)

ext2 文件系统格式化时，要根据服务器的用途设置好合理的 block 大小：
- 若服务器存储大部分为小文件，block 尽量小，可以减少空间浪费
- 若服务器存储大部分为大文件，block 尽量大，可以减少 inode 使用

数据块根据不同的文件类型有以下几种情况：

- 对于常规文件，文件的数据存储在数据块中
- 对于目录，该目录下的所有文件名和目录名存储在数据块中，注意文件名保存在它所在目录的数据块中，除文件名之外，ls -l 命令看到的其它信息都保存在该文件的 inode 中。注意这个概念：目录也是一种文件，是一种特殊类型的文件
- 对于符号链接，如果目标路径名较短则直接保存在 inode 中以便更快地查找，如果目标路径名较长则分配一个数据块来保存
- 设备文件、FIFO和socket 等特殊文件没有数据块，设备文件的主设备号和次设备号保存在 inode 中


## 三、使用 dumpe2fs 观察 Linux 文件系统

可以使用 `dumpe2fs` 查看 ext2文件系统

<div align="center"><image src="../doc/dumpe2fs查看ext2文件系统.png"></image></div>

如上所示，利用 dumpe2fs 可以查询到非常多的信息，输出内容主要可以区分为上半部是 superblock 内容， 下半部则是每个 block group 的信息了。

从上面的表格中我们可以观察到这个 /dev/hdc2 规划的 block 为 4K， 第一个 block 号码为 0 号，且 block group 内的所有信息都以 block 的号码来表示的。 然后在 superblock 中还有谈到目前这个文件系统的可用 block 与 inode 数量喔！

至于 block group 的内容我们单纯看 Group0 信息好了。从上表中我们可以发现：

- Group0 所占用的 block 号码由 0 到 32767 号，superblock 则在第 0 号的 block 区块内！
- 文件系统描述说明在第 1 号 block 中；
- block bitmap 与 inode bitmap 则在 627 及 628 的 block 号码上。
- 至于 inode table 分布于 629-1641 的 block 号码中！
- 由于 (1)一个 inode 占用 128 bytes ，(2)总共有 1641 - 629 + 1(629本身) = 1013 个 block 花在 inode table 上， (3)每个 block 的大小为 4096 bytes(4K)。由这些数据可以算出 inode 的数量共有 1013 * 4096 / 128 = 32416 个 inode 啦！
- 这个 Group0 目前没有可用的 block 了，但是有剩余 32405 个 inode 未被使用；
- 剩余的 inode 号码为 12 号到 32416 号。

参考：
- 《鸟哥的Linux私房菜》