# 文件操作

<!-- TOC -->

- [一、原理](#一原理)
    - [1. Linux 文件系统](#1-linux-文件系统)
    - [2. 内核管理打开文件模型](#2-内核管理打开文件模型)
    - [3. 文件 I/O 缓冲](#3-文件-io-缓冲)
- [二. 文件 I/O](#二-文件-io)
    - [1. open](#1-open)
    - [2. creat](#2-creat)
    - [3. close](#3-close)
    - [4. lseek](#4-lseek)
    - [5. read](#5-read)
    - [6. write](#6-write)
    - [7. 与文件 I/O 有关的原子操作](#7-与文件-io-有关的原子操作)
- [三、与文件表项有关的文件属性](#三与文件表项有关的文件属性)
    - [1. dup 和 dup2](#1-dup-和-dup2)
    - [2. fcntl](#2-fcntl)
    - [3. ioctl](#3-ioctl)
- [四、与 inode 有关的文件属性](#四与-inode-有关的文件属性)
    - [1. stat](#1-stat)
    - [2. stat.st_mode 之文件类型](#2-statst_mode-之文件类型)
    - [3. stat.st_mode 之设置用户 ID 和设置组 ID 以及 文件所有者 ID(stat.st_uid) 和 所属组 ID(stat.st_gid)](#3-statst_mode-之设置用户-id-和设置组-id-以及-文件所有者-idstatst_uid-和-所属组-idstatst_gid)
    - [4. stat.st_mode 之文件访问权限](#4-statst_mode-之文件访问权限)
- [五、目录](#五目录)
- [六、](#六)
    - [2.](#2)
    - [二、umask 掩码](#二umask-掩码)
        - [三、最大打开文件个数](#三最大打开文件个数)
        - [三、阻塞和非阻塞](#三阻塞和非阻塞)
    - [1. 阻塞](#1-阻塞)
        - [1.1 阻塞读终端](#11-阻塞读终端)
    - [2. 非阻塞](#2-非阻塞)
        - [2.1 非阻塞读终端](#21-非阻塞读终端)
- [一、stat](#一stat)
- [二、access](#二access)
- [一、chmod](#一chmod)
- [二、chown](#二chown)
- [一、link](#一link)
- [二、symlink](#二symlink)
- [三、readlink](#三readlink)
- [四、unlink](#四unlink)
- [一、mkdir](#一mkdir)
- [二、rmdir](#二rmdir)
- [三、opendir、fdopendir](#三opendirfdopendir)
- [四、readdir](#四readdir)
- [五、rewindir](#五rewindir)
- [六、telldir、seekdir](#六telldirseekdir)
- [七、closedir](#七closedir)
- [八、递归遍历目录](#八递归遍历目录)

<!-- /TOC -->

## 一、原理

### 1. Linux 文件系统

更详细的 [Linux文件系统描述]()

把一个磁盘分成一个或多个分区，每个分区可以包含一个文件系统，下图是一个典型的 Linux 文件系统：

<div align="center"><img src="doc/磁盘分区和文件系统.png" width="700"></img></div>


图中 i 节点是固定长度的记录项，其中包含了有关文件的大部分信息，i 节点所维护的信息如下所示：

1. 文件类型（如，常规文件、目录、符号链接、字符设备等）
2. 文件所有者（用户 ID 或 UID）
3. 文件所属组（组 ID 或 GID）
4. 3 类用户的访问权限：所有者、所属组、其他人
5. 3 个时间戳：文件最后访问时间、最后修改时间、文件状态最后更改时间
6. 指向文件的硬链接数量
7. 文件的大小，以字节为单位
8. 实际分配给文件的块数量，一般以 512 字节块为单位
9. 指向文件数据块的指针

下图描述了 i 节点、数据块、目录块之间的关系：

<div align="center"><img src="doc/较详细的柱面组的i节点和数据块.png" width="700"></img></div>

可以发现：

1. 图中有两个目录项指向同一个 i 节点，每个 i 节点都有一个链接计数，其值是指向该 i 节点的目录项数，只有当链接数减少为 0 时，才可删除该文件（也就是可以释放该文件所占的数据块），因此删除一个目录项的函数被称为 unlink 而不是 delete，在 stat 结构中，链接计数包含在 `st_nlink` 成员中，其基本系统数据类型为 nlink_t，这种链接称为 **硬链接**，常量 `LINK_MAX` 指定了一个文件链接数的最大值

2. 另一种链接类型为 **符号链接（symbolic link）**，符号链接文件的实际内容（在数据块中）包含了该符号链接所指向的文件的名字，所以符号链接可以跨文件系统，符号链接文件的 i 节点中的文件类型为 S_IFLNK

3. i 节点中包含了文件有关的所有信息：文件类型、文件访问权限位、文件长度、指向文件实际数据块的指针等，stat 结构的大多数信息都取自 i 节点，只有两项重要数据放在目录项中：文件名和 i 节点编号

4. 因为目录项中的 i 节点编号指向同一文件系统中相应 i 节点，所以一个目录项不能指向另一个文件系统的 i 节点，这也是硬链接不能跨文件系统的原因

5. 当在不更换文件系统的情况下为一个文件重命名时，该文件的实际内容并未移动，只需构造一个指向现有 i 节点的新目录项，并删除老的目录项，链接计数不会改变

6. 任何一个叶目录（不包含其他目录的目录）的链接计数总是 2，数值 2 来自于命名该目录的的目录项以及在该目录中的 `.` 项

   以创建新目录 testdir 为例：`mkdir testdir`，下图为创建了目录 testdir 后的文件系统结构：

   <div align="center"><img src="doc/创建了目录testdir后的文件系统实例.png" width="700"></img></div>

   - 编号为 2549 的 i 节点，其类型字段表示其为目录，其链接计数为 2，分别来自本目录的 `.` 项以及父目录中的目录项，从父目录的目录项可以看出该目录名为 testdir
   - 编号为 1267 的 i 节点，其类型字段表示其为目录，其链接计数至少为 3，一个是命名它的父目录的目录项，第二个是在该目录的 `.` 项，第三个是其子目录 testdir 的 `..` 项

### 2. 内核管理打开文件模型

对于内核而言，所有打开的文件都通过文件描述符引用，文件描述符是一个非负整数，当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。读写操作文件都通过操作该文件描述符完成。

- 每个进程在内核进程表中都有一个记录项，记录项中包含一张打开文件描述符表，每个打开的文件描述符占用一项，与每个文件描述符相关联的是：

  1. 文件描述符状态（close_on_exec）
  2. 指向一个文件表项的指针

- 内核为所有打开文件维持一张文件表，每个文件表项包含：

  1. 文件状态标志（读、写、追加、同步、非阻塞等）
  2. 当前文件偏移量
  3. 指向该文件 v 节点表项的指针

- 每个打开文件（或设备）都有一个 v 节点（v-node）结构。v 节点包含了文件类型和对此文件进行各种操作函数的指针，对于大多数文件，v 节点还包含了该文件的 i 节点(i-node，索引节点)，i 节点中包含了文件的所有者、文件长度、文件实际数据块指针等，这些信息是在打开文件时从磁盘读入内存的，所以

每当运行一个新程序时，系统为其打开 3 个文件描述符，即 **标准输入（STDIN_FILENO, 0）、标准输出（STDOUT_FILENO, 1）、标准错误（STDERR_FILENO, 2）**，文件描述符的变化范围为 `0~OPEN_MAX-1`

<div align="center"><img src="doc/打开文件的内核数据结构.png" width="700"></img></div>

当两个独立进程打开同一个文件，每个进程都有各自的文件表项，但是一个打开只有一个 v 节点表项。这样每个进程都有自己对该文件的当前偏移量和文件打开状态

<div align="center"><img src="doc/两个独立进程各自打开同一个文件.png" width="700"></img></div>

可能有多个文件描述符指向同一个文件表项：

1. 使用 `dup` 函数
2. `fork` 之后，父进程、子进程各自的每一个打开文件描述符共享同一个文件表项

文件描述符标志和文件状态标志在作用范围方面有区别：前者只用于一个进程的一个描述符，后者则应用于指向给定文件表项的任何进程的所有描述符

### 3. 文件 I/O 缓冲

出于效率考虑，系统 I/O 调用（即内核）和标准 C 语言库 I/O 函数（即 stdio 函数）在操作磁盘文件时会对数据进行缓冲，通常以有无 stdio 缓冲区将 I/O 函数分为 **带缓冲 I/O** 和 **不带缓冲 I/O**，带缓冲 I/O 即 printf()、fputc() 等 stdio 函数库调用，不带缓冲 I/O 即 read()、write() 等使用文件描述符的系统调用

<div align="center"><img src="doc/IO缓冲小结.png" height="600"></img></div>

如上图，文件 I/O 的两道缓冲：

1. 文件 I/O 的内核缓冲：缓冲区高速缓存

   read() 和 write() 系统调用在操作磁盘文件时不会直接发起磁盘访问，而是仅仅在用户空间缓冲区与内核缓冲区高速缓存（kernel buffer cache）之间复制数据

   - 对输出而言，write() 会将数据从用户空间内存传递到内核空间的缓冲区中，在后续的某个时刻，内核会将其缓冲区中的数据写入磁盘，在此期间，若另一个进程试图读取该文件的内容，则内核将自动从缓冲区高速缓存中提供这些数据，而不是从文件中读取过期的内容

   - 对输入而言，内核从磁盘中读取数据并存储到内核缓冲区中，read() 调用将从该缓冲区中读取数据，直至把缓冲区中的数据取完，这时，内核会将文件的下一段内容读入缓冲区高速缓存

   Linux 内核对缓冲区高速缓存的大小上限受制于两个因素：可用的物理内存总量以及出于其他目的对物理内存的需求

   使用 fsync()/fdatasync()/sync() 可以强制将内核缓冲区内容同步到磁盘

2. stdio 库的缓冲

   C 语言函数的 I/O 函数在操作磁盘文件时，缓冲大块数据以减少系统调用次数，使用 stdio 库可以使编程者免于自行处理对数据的缓冲，任何时候都可以使用 fflush() 库函数强制将 stdio 输出流中的数据通过 write() 刷新到内核缓冲区中



## 二. 文件 I/O

### 1. open

```
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *path, int aflag, .../* mode_t mode */);
int openat(int fd, const char *path, int aflag, .../* mode_t mode */);
```

- `pathname` 参数是要打开或创建的文件名，既可以是相对路径也可以是绝对路径
- `flags` 参数有一系列常数值可供选择，可以同时选择多个常数用按位或运算符连接起来，所以这些常数的宏定义都以 O_开头，表示 or

  有三个必选项：以下三个常数中必须指定一个，且仅允许指定一个

  1. `O_RDONLY` 只读打开
  2. `O_WRONLY` 只写打开
  3. `O_RDWR`   可读可写打开
  4. `O_EXEC`   只执行打开
  5. `O_SEARCH` 只搜索打开（应用于目录）

  以下可选项可以同时指定 0 个或多个，和必选项按位或起来作为 flags 参数。可选项有很多，这里只介绍一部分，其它选项可参考 `open(2)` 的 Man Page：

  - `O_APPEND`    

    每次写时都追加到文件的尾端

  - `O_CLOEXEC`   

    把 `FD_CLOEXEC` 常量设置为文件描述符状态

  - `O_CREAT`     

    若此文件不存在则创建它。使用此选项时需要提供参数 mode，表示该文件的访问权限

  - `O_DIRECTORY` 

    如果 path 引用的不是目录，则出错

  - `O_EXCL`      

    如果同时指定了 O_CREAT，并且文件已存在，则出错返回，可以用此测试一个文件是否存在，如果不存在，则创建此文件，这使测试和创建两者成为一个原子操作

  - `O_NOFOLLOW`  

    如果 path 引用的是一个符号链接，则出错

  - `O_NONBLOCK`  

    如果 path 引用的是一个 FIFO、块特殊文件或者字特殊文件，则此选项为文件的本次打开操作和后续 I/O 操作设置非阻塞方式

  - `O_TRUNC`     

    如果文件已存在，并且以只写或读-写方式打开，则将其长度截断（Truncate）为 0 字节

  - `O_SYNC`      

    使每次 write 等待物理 I/O 操作完成，包括由该 write 操作引起的文件属性更新所需的 I/O

  - `O_DSYNC`     

    使每次 write 等待物理 I/O 操作完成，但是如果该写操作并不影响读取刚写入的数据，则不需要等待文件属性被更新

  - `O_RSYNC`     
  
    使每一个以文件描述符作为参数进行的 read 操作等待，直至所有对文件同一部分挂起的写操作都完成

- `mode` 参数指定文件权限，可以用八进制数表示，比如 0644 表示 -rw-r-r–，也可以用 S_IRUSR、S_IWUSR 等宏定义按位或起来表示，详见 open(2) 的 Man Page。要注意的是，文件权限由 open 的 mode 参数和当前进程的 umask 掩码共同决定。

  ```
  S_IRWXU  00700 user (file owner) has read, write, and execute permission
  S_IRUSR  00400 user has read permission
  S_IWUSR  00200 user has write permission
  S_IXUSR  00100 user has execute permission
  S_IRWXG  00070 group has read, write, and execute permission
  S_IRGRP  00040 group has read permission
  S_IWGRP  00020 group has write permission
  S_IXGRP  00010 group has execute permission
  S_IRWXO  00007 others have read, write, and execute permission
  S_IROTH  00004 others have read permission
  S_IWOTH  00002 others have write permission
  S_IXOTH  00001 others have execute permission
  S_ISUID  0004000 set-user-ID bit
  S_ISGID  0002000 set-group-ID bit
  S_ISVTX  0001000 sticky bit
  ```

- 返回值：两函数成功都返回新分配的文件描述符，出错返回 -1 并设置 errno

open 和 openat 返回的文件描述符一定是最小的未用描述符数值，这点被用来在标准输入、标准输出或标准错误上打开新文件

fd 参数把 open 和 openat 函数区分开，共有 3 种可能性：

1. path 参数指定的是绝对路径名，这种情况下，fd 参数被忽略， openat 就相当于 open
2. path 参数指定的是相对路径名，fd 参数指出了相对路径名在文件系统种的开始地址，fd 参数是通过打开相对路径名所在目录来获取
3. path 参数指定了相对路径名，fd 参数具有特殊值 AT_FDCWD。这种情况下，路径名在当前工作目录中获取，openat 函数在操作上

> 后续的 xxx 函数和 xxxat 函数的区别与此类似

openat 函数可以解决两个问题：

1. 让线程可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录
2. 可以避免 time-of-check-to-time-of-use（TOCTTOU）错误

   > TOCTTOU 错误的基本思想是：如果有两个基本文件的函数调用，其中第二个调用依赖于第一个调用的结果，那么程序是脆弱的。因为两个调用并不是原子操作，在两个函数调用之间文件可能改变了，这样也就造成了第一个调用的结果就不再有效，使得程序最终的结果是错误的。文件系统命名空间中的 TOCTTOU 错误通常处理的就是那些颠覆文件系统权限的小把戏，这些小把戏通过骗取特权程序降低特权文件的权限控制或者让特权文件打开一个安全漏洞等方式进行

### 2. creat

```
#include <fcntl.h>

int creat(const char *path, mode_t mode);
```

- 成功返回新文件的 fd，失败返回 -1 并设置 errno

creat 函数等效于：

```
open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);
```

creat 的问题在于它以只写方式打开所创建的文件，如果要创建一个临时文件，先写后读该临时文件，则需要先调用 creat、close，然后调用 open。现在这个过程可以用一行 open 实现：

```
open(path, O_RDWR | O_CREAT | O_TRUNC, mode);
```

### 3. close

```
#include <unistd.h>

int close(int fd);
```
- close 成功返回 0，出错返回 -1 并设置 errno
- 关闭一个文件时会释放该进程加在该文件上的所有记录锁
- 当一个进程终止时，内核自动关闭它打开的所有文件

### 4. lseek

每个打开文件都有一个 **当前文件偏移量（current file offset）**，偏移量通常是一个非负整数，用以度量从文件开始处计算的字节数，通常，读、写操作都从当前文件偏移量处开始，并使偏移量增加所读写的字节数，系统默认当打开一个文件时，除非指定 O_APPEND 选项，否则该偏移量设置为 0

```
#include <unistd.h>

off_t lseek(int fd, off_t offset, int whence);
```

- whence 有三种情况：
  1. 若 whence 是 `SEEK_SET`，则将偏移量设置为距文件开始处 offset 个字节
  2. 若 whence 是 `SEEK_CUR`，则将偏移量的当前值加 offset，offset 可正可负
  3. 若 whence 是 `SEEK_END`，则将偏移量设置为文件当前长度加 offset，offset 可正可负
- lseek 成功返回新的偏移量，失败返回 -1 并设置 errno

  ```
  off_t currpos;
  currpos = lseek(fd, 0, SEEK_CUR);
  ```

  1. 上述代码可以确定当前文件的当前偏移量
  2. 上述方法还可以用来确定所设计的文件是否可以设置偏移量：如果文件描述符指向的是一个管道、FIFO或网络套接字，则 lseek 返回 -1，并将 errno 设置为 ESPIPE
  3. 测试 lseek 返回值时，不要测试它是否小于 0，而要测试它是否等于 -1，因为某些设备可能允许负的偏移量

- lseek 将当前文件偏移量记录在内核的打开文件表中（见一.1. 内核管理打开文件模型），因此修改偏移量并不引起 I/O 操作
- 当文件偏移量设为大于文件当前长度时，下次写将加长该文件，形成文件空洞，空洞内的内容都被读为 0，只有在空洞中写入内容时才分配磁盘块

  例如：下面代码用于创建一个具有空洞的文件：

  ```c
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>
  #include <string.h>
  #include <unistd.h>
  #include <errno.h>
  #include <stdio.h>
  #include <stdlib.h>

  char buf1[] = "abcdefghij";
  char buf2[] = "ABCDEFGHIJ";

  int main(void)
  {
    int fd;
    if ( (fd = open("file.hole", O_WRONLY | O_CREAT | O_TRUNC, 00777)) < 0)
    {
        printf("open file failed: %s\n", strerror(errno));
    }
    if (write(fd, buf1, strlen(buf1)) != strlen(buf1))
    {
        printf("write file failed: %s\n", strerror(errno));
    }
    // offset now = 10

    if (lseek(fd, 16384, SEEK_SET) == -1)
    {
        printf("lseek failed: %s\n", strerror(errno));
    }
    // offset now = 16384

    if (write(fd, buf2, strlen(buf2)) != strlen(buf2))
    {
        printf("write failed: %s\n", strerror(errno));
    }
    // offset now = 16394

    exit(0);
  }
  ```

  使用 `od -c` 可以查看该空洞文件的实际内容，从 `ls -ls` 的输出可以看到虽然 file.hole 和 file.nohole 的文件大小相同，但是 file.hole 只占用了 8 个磁盘块，而 file.nohole 占用了 20 个磁盘块：

  ```
  $ od -c file.hole
  0000000   a   b   c   d   e   f   g   h   i   j  \0  \0  \0  \0  \0  \0
  0000020  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
  *
  0040000   A   B   C   D   E   F   G   H   I   J
  0040012
  
  $ ls -ls file.hole file.nohole
   8 -rwxrwxr-x 1 lhg lhg 16394 8月  10 17:09 file.hole
  20 -rwxrwxr-x 1 lhg lhg 16394 8月  10 17:09 file.nohole
  ```

### 5. read

```
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t nbytes);
```

- read 成功，则返回读到的字节数；到达文件末尾，返回 0，出错返回 -1
- nbytes 指定 buf 的大小

有以下几种情况可使实际读到的字节数少于要求读的字节数：

1. 读普通文件时，在读到要求字节数之前已到达了文件尾端，此时返回实际读到的字节数
2. 当从终端设备读时，通常一次最多读一行
3. 当从网络读时，网络中的缓冲机制可能造成返回值小于所要求读的字节数
4. 当从管道或 FIFO 读时，若管道中包含的字节少于所需的数量，则 read 只返回实际可用的字节数
5. 当某些面向记录的设备（如磁带）读时，一次最多返回一个记录
6. 当一信号造成中断，而已经读了部分数据量时，返回已经读到的字节数

### 6. write

```
#include <unistd.h>

ssize_t write(int fd, const void *buf, size_t nbytes);
```

- wirte 成功，返回已写的字节数，返回字节数通常与参数 nbytes 相同，否则表示出错；失败返回 -1 并设置 errno
- nbytes 指示 buf 中要写入的内容的长度

### 7. 与文件 I/O 有关的原子操作

## 三、与文件表项有关的文件属性

### 1. dup 和 dup2 

```
#include <unistd.h>

int dup(int fd);
int dup2(int fd, int fd2);
```

dup 和 dup2 都用来复制一个现有的文件描述符：

- 由 dup 返回的新文件描述符一定是当前可用的文件描述符中的最小数值
- dup2 使用 fd2 指定新描述符的值：
  - 如果 fd2 已经打开，则先将其关闭
  - 如果 fd2 == fd，则 dup2 直接 fd2，而不关闭再重新打开，否则 fd2 原来的 FD_CLOEXEC 文件描述符标志就被清除了

dup 和 dup2 函数返回的新文件描述符和参数 fd 共享同一个文件表项：

<div align="center"><img src=doc/dup后的内核数据结构.png width="700"></img></div>

由上图可以看出：dup 后的两个描述符指向同一个文件表项，所以它们共享同一文件状态标志（读、写、追加等）以及同一当前文件偏移量

还可以通过 fcntl 函数复制文件描述符：

- 调用 `dup(fd)` 等效于 `fcntl(fd, F_DUPFD, 0)`
- 调用 `dup2(fd, fd2)` 等效于 

  ```
  close(fd2); 
  fcntl(fd, F_DUPFD, fd2)
  ```

  dup2() 和 fcntl() 以下不同：
  1. dup2 是一个原子操作
  2. dup2 和 fcntl 有一些不同的 errno

### 2. fcntl

fcntl 函数可以改变已打开文件的属性：

```c
#include <fcntl.h>

int fcntl(int fd, int cmd, ... /* int arg */);
```

fcntl 函数有以下 5 种功能：

1. 复制一个已有的描述符（cmd = F_DUPFD 或 F_DUPFD_CLOEXEC）
2. 获取/设置文件描述符标志（cmd = F_GETFD 或 F_SETFD）
3. 获取/设置文件状态标志（cmd = F_GETFL 或 F_SETFL）
4. 获取/设置异步 I/O 所有权（cmd = F_GETOWN 或 F_SETOWN）
5. 获取/设置记录锁（cmd = F_GETLK、F_SETLK 或 F_SETLKW）

fcntl 的返回值跟 cmd 相关，如果出错，所有命令都返回 -1，如果成功则返回跟 cmd 相关的值

cmd 可取以下值之一：

- `F_DUPFD`

  复制文件描述符 fd，返回尚未打开的描述符中大于或等于第三个参数值的最小值，新描述符有自己的一套文件描述符标志，其 FD_CLOEXEC 文件描述符标志被清除

- `F_DUPFD_CLOEXEC`

  复制文件描述符，设置与新描述符关联的 FD_CLOEXEC 文件描述符标志的值，返回新文件描述符

- `F_GETFD`

  返回 fd 的文件描述符标志（目前只有一个文件描述符标志 FD_CLOEXEC）

- `F_SETFD`

  按照第三个参数的值设置 fd 的文件描述符标志

- `F_GETFL`

  返回 fd 的文件状态标志，open 函数中指定了文件的状态标志：

  <div align="center"><img src="doc/对于fcntl的文件状态标志.png" width="600"></img></div>

  由于 5 个访问方式标志（O_RDONLY、O_WRONLY、O_RDWR、O_EXEC、O_SEARCH）并不各占一位，因此这 5 个值互斥，因此必须用屏蔽字 `O_ACCMODE` 取得访问方式位，然后将结果与这 5 个值中的每一个比较

  下面的程序用于打印指定文件的状态标志描述：

  ```c
  #include <fcntl.h>
  #include <stdio.h>
  #include <stdlib.h>

  int main(int argc, char *argv[])
  {
      int val;

      if (argc != 2)
      {
          printf("usage: a.out <argument>\n");
          return 0;
      }

      if ((val = fcntl(atoi(argv[1]), F_GETFL, 0)) < 0)
      {
          perror("fcntl failed");
          return 0;
      }

      switch (val & O_ACCMODE)
      {
      case O_RDONLY:
          printf("read only\n");
          break;
      case O_WRONLY:
          printf("write only\n");
          break;
      case O_RDWR:
          printf("read write\n");
          break;
    
      default:
          printf("unknown access mode\n");
          return 0;
      }

      if (val & O_APPEND)
          printf(", append\n");
      if (val & O_NONBLOCK)
          printf(", nonblocking\n");
      if (val & O_SYNC)
          printf(", synchronous writes\n");
    
      return 0;
  }
  ```

- `F_SETFL`

  将文件状态标志设置为第 3 个参数的值，可以更改的几个标志是：O_APPEND、O_NONBLOCK、O_SYNC、O_DSYNC、O_RSYNC、O_FSYNC 和 O_ASYNC

  在修改文件描述符标志或文件状态标志时必须谨慎，先要获得现在的标志值，然后按照期望修改它，最后设置新标志值，下面是一个文件描述符设置一个或多个文件状态标志的函数：

  ```c
  #include <fcntl.h>
  #include <stdio.h>

  void set_fl(int fd, int flags)
  {
      int val;

      if ((val = fcntl(fd, F_GETFL, 0)) < 0)
      {
          perror("fcntl getfl failed");
          return ;
      }

      val |= flags;   // 设置 flags
      //val &= ~flags; // 清除 flags

      if (fcntl(fd, F_SETFL, val) < 0)
      {
          perror("fcntl setfl failed");
          return ;
      }
  }
  ```

- `F_GETOWN`

  获取当前接收 SIGIO 和 SIGURG 信号的进程 ID 或进程组 ID，返回值为一个正的进程 ID 或负的进程组 ID

- `F_SETOWN`

  设置接收 SIGIO 和 SIGURG 信号的进程 ID 或进程组 ID，正的 arg 指定一个进程 ID，负的 arg ，其绝对值表示进程组 ID

### 3. ioctl

## 四、与 inode 有关的文件属性

### 1. stat

```c
#include <sys/stat.h>

int stat(const char *restrict pathname, struct stat *restrict buf);
int fstat(int fd, struct stat *buf);
int lstat(const char *restrict pathname, struct stat *restrict buf);
int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag);
```

- `stat` 返回给定 pathname 文件有关的信息结构
- `fstat` 返回在描述符 fd 上打开文件的有关信息
- `lstat` lstat 类似 stat，当命令的文件是一个符号链接时，lstat 返回该符号链接的有关信息，而不是由该符号链接引用的文件的信息
- `fstatat` 为一个相对于 fd 指向的打开目录的路径名返回文件信息，flag 控制着是否跟随着一个符号链接，当 `AT_SYMLINK_NOFOLLOW` 标志设置时，fstatat 不会跟随符号链接，而是返回符号链接本身的信息，否则，默认情况下，返回的是符号链接指向的实际文件的信息

buf 指向的 stat 文件信息结构定义如下：

```c
struct stat {
    dev_t st_dev; /* ID of device containing file */
    ino_t st_ino; /* inode number */
    mode_t st_mode; /* protection */
    nlink_t st_nlink; /* number of hard links */
    uid_t st_uid; /* user ID of owner */
    gid_t st_gid; /* group ID of owner */
    dev_t st_rdev; /* device ID (if special file) */
    off_t st_size; /* total size, in bytes */
    blksize_t st_blksize; /* blocksize for file system I/O */
    blkcnt_t st_blocks; /* number of 512B blocks allocated */
    time_t st_atime; /* time of last access */
    time_t st_mtime; /* time of last modification */
    time_t st_ctime; /* time of last status change */
};
```

### 2. stat.st_mode 之文件类型

Linux 中有其中文件类型：

1. 普通文件（regular file）
2. 目录文件（directory file）：目录文件中包含了其他文件的名字以及指向与这些文件有关信息的指针。对一个目录文件具有读权限的任一进程都可以读该目录的内容，但只有内核可以直接写目录文件
3. 块特殊文件（block special file）：提供对设备（如磁盘）带缓冲的访问，每次访问以固定长度为单位进行
4. 字符特殊文件（character special file）：提供对设备不带缓冲的访问，每次访问长度可变，系统中的设备要么是字符特殊文件，要么是块特殊文件
5. FIFO，命名管道文件，用于进程间通信
6. 套接字（socket）：用户进程间的网络通信
7. 符号链接（symbolic link）：符号链接指向另一个文件

文件类型信息包含在 stat 结构的 `st_mode` 成员中，可用下面的宏确定文件类型，宏的参数为 `st_mode` 成员：

| 宏 | 文件类型 |
| --- | --- |
| S_ISREG() | 普通文件 |
| S_ISDIR() | 目录文件 |
| S_ISCHR() | 字符特殊文件 |
| S_ISBLK() | 块特殊文件 |
| S_ISFIFO() | 管道或 FIFO |
| S_ISLNK() | 符号链接 |
| S_ISSOCK() | 套接字 |

还可以用下面的宏确定文件是否为 IPC 对象（如消息队列和信号量等），它们的参数不是 `st_mode`，而是指向 `stat` 结构的指针：

| 宏 | 对象的类型 |
| --- | --- |
| S_TYPEISMQ() | 消息队列 |
| S_TYPEISSEM() | 信号量 |
| S_TYPEISSHM() | 共享存储对象 |

下面的程序针对每一个命令行参数打印其文件类型：

```c

```

### 3. stat.st_mode 之设置用户 ID 和设置组 ID 以及 文件所有者 ID(stat.st_uid) 和 所属组 ID(stat.st_gid)

- 每个文件都有一个所有者和所属组，所有者由 stat 结构中的 `st_uid` 指定，所属组由 `st_gid` 指定
- 当执行一个程序文件时，进程的有效用户 ID 通常就是实际用户 ID，有效组 ID 通常是实际组 ID。在 `st_mode` 中可以设置一个特殊标志，其含义是当执行此文件时，将进程的有效用户 ID 设置为文件所有者的 ID（即 st_uid）与此类似，在 `st_mode` 中还可以设置另一位，它将执行此文件的进程的有效组 ID 设置为文件的组所有 ID（即 st_gid），`st_mode` 中的这两位分别被称为 **设置用户 ID（set-user-id）** 和 **设置组 ID（set-group-id）**，可用下面两个常量测试：

1. `S_ISUID`

   测试是否设置用户 ID 位

2. `S_ISGID`

   测试是否设置组 ID 位 

### 4. stat.st_mode 之文件访问权限

`st_mode` 中包含了对文件的访问权限位，每种文件类型都有 9 个访问权限位（access permission）：

| st_mode 屏蔽 | 含义 |
| --- | --- |
| S_IRUSR | 用户读 |
| S_IWUSR | 用户写 |
| S_IXUSR | 用户执行 |
| S_IRGRP | 组读 |
| S_IWGRP | 组写 |
| S_IXGRP | 组执行 |
| S_IROTH | 其他读 |
| S_IWOTH | 其他写 |
| S_IXOTH | 其他执行 |

这 9 个权限访问位在不同函数中使用需要注意的点：

- 当我们用名字打开任一类型的文件时，对该名字中包含的每一个目录，包括它可能隐含的当前工作目录都应具有执行权限，这就是为什么对于目录其执行权限位常被称为搜索位的原因，对于目录的读权限和执行权限的意义是不同的，读权限允许我们读目录，获得在该目录中所有文件名的列表，而对该目录的执行权限使我们可通过该目录（也就是搜索该目录）寻找一个特定的文件名
- 对一个文件的读/写权限决定了我们是否能够打开现有文件进行读/写操作
- 在 `open` 函数中指定 `O_TRUNC` 标志时，必须对该文件具有写权限
- 在一个目录中创建新文件时，必须对该目录具有写权限和执行权限
- 删除一个现有文件时，必须对包含该文件的目录具有写权限和执行权限，对该文件本身则不需要读、写权限
- 如果用 `exec` 系列函数执行某个文件，都必须该文件具有执行权限，且该文件必须是一个普通文件

进程每次打开、创建或删除一个文件时，内核就要进行文件访问权限测试，测试内容如下：

1. 若进程的有效用户 ID 是 0（超级用户），则允许访问，超级用户拥有对整个文件系统最大的访问权限
2. 若进程的有效用户 ID 等于文件的所有者 ID（即进程拥有此文件），那么如果所有者相对应的读写执行位被设置时，则允许访问，否则拒绝访问
3. 若进程的有效组 ID 或进程的附属组 ID 之一等于文件的组 ID，那么如果组适当的访问权限位被设置时，则允许访问，否则拒绝访问
4. 若其他用户适当的访问权限位被设置，则允许访问，否则拒绝访问

## 五、目录

## 六、




### 2. 




### 二、umask 掩码

真正创建出来的文件权限是由设置权限 `&~` umask 掩码得来的

Shell进程的umask掩码可以用umask命令查看：

```
$ umask
0002
```

用 touch 命令创建一个文件时，创建权限是 0666，而 touch 进程继承了 Shell 进程的 umask 掩码，所以最终的文件权限是 0666 &~ 022=0644

```
$ touch file123
$ ls -l file123
-rw-rw-r-- 1 xingwenpeng xingwenpeng 0 9月11 23:48 file123
```

可以把 Shell 进程的 umask 改成 0 来证明 touch 创建文件的权限本来应该是 0666

```
$ rm file123
$ umask 0
$ touch file123
$ ls -l file123
-rw-rw-rw- 1 xingwenpeng xingwenpeng 0 9月11 23:52 file123
```

#### 三、最大打开文件个数

查看当前系统允许打开最大文件个数（硬限制）：

```
cat /proc/sys/fs/file-max
```

当前默认设置最大打开文件个数 1024（软限制）：

```
ulimit -a
```

修改默认设置最大打开文件个数为 4096：

```
ulimit -n 4096
```



#### 三、阻塞和非阻塞

### 1. 阻塞

阻塞（Block）即当进程调用一个阻塞的系统函数时，该进程被置于睡眠（Sleep）状态，这时内核调度其它进程运行，直到该进程等待的事件发生了（比如网络上接收到数据包，或者调用sleep指定的睡眠时间到了）它才有可能继续运行。

读/写常规文件是不会阻塞的，不管读多少字节，read 一定会在有限的时间内返回。而从终端设备或网络读则不一定，如果从终端输入的数据没有换行符，调用 read 读终端设备就会阻塞，如果网络上没有接收到数据包，调用 read 从网络读就会阻塞，至于会阻塞多长时间也是不确定的，如果一直没有数据到达就一直阻塞在那里。

#### 1.1 阻塞读终端

```c
#include <unistd.h>
#include <stdlib.h>

int main(void)
{
    char buf[10];
    int n;
    n = read(STDIN_FILENO, buf, 10);
    if (n < 0) {
        perror("read STDIN_FILENO");
        exit(1);
    }

    write(STDOUT_FILENO, buf, n);
    return 0;
}
```

执行结果：

```
$ ./a.out
hello（回车）
hello

$ ./a.out
hello world（回车）
hello worl$ d
bash: d: command not found
```

第一次执行 a.out 的结果很正常，而第二次执行的过程有点特殊，现在分析一下： 

a.out 调用 read 时睡眠等待，直到终端设备输入了换行符才从 read 返回，read 只读走 10 个字符，剩下的字符仍然保存在内核的终端设备输入缓冲区中。a.out 进程打印并退出，这时 Shell 进程恢复运行，Shell 继续从终端读取用户输入的命令，于是读走了终端设备输入缓冲区中剩下的字符 d 和换行符，把它当成一条命令解释执行，结果发现执行不了，没有 d 这个命令。

### 2. 非阻塞


如果在open一个设备时指定了O_NONBLOCK标志，read/write就不会阻塞。

以read为例，如果设备暂时没有数据可读就返回-1，同时置errno为EWOULDBLOCK（或者EAGAIN，这两个宏定义的值相同），表示本来应该阻塞在这里（would block，虚拟语气），事实上并没有阻塞而是直接返回错误，调用者应该试着再读一次（again）。这种行为方式称为轮询（Poll），调用者只是查询一下，而不是阻塞在这里死等，这样可以同时监视多个设备：

```
while(1) {
    非阻塞read(设备1);
    if(设备1有数据到达)
        处理数据;
    非阻塞read(设备2);
    if(设备2有数据到达)
        处理数据;
    ...
}
```

后面可以通过 IO 服用函数来管理非阻塞 IO

#### 2.1 非阻塞读终端

```c
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>

#define MSG_TRY "try again\n"

int main(void)
{
    char buf[10];
    int fd, n;
    fd = open("/dev/tty", O_RDONLY|O_NONBLOCK);
    if(fd<0) {
        perror("open /dev/tty");
        exit(1);
    }
    tryagain:
    n = read(fd, buf, 10);
    if (n < 0) {
        if (errno == EAGAIN) {
            sleep(1);
            write(STDOUT_FILENO, MSG_TRY, strlen(MSG_TRY));
            goto tryagain;
        }
        perror("read /dev/tty");
        exit(1);
    }
    write(STDOUT_FILENO, buf, n);
    close(fd);
    return 0;
}
```

# 获取文件信息 stat

## 一、stat

```
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int stat(const char *path, struct stat *buf);
int fstat(int fd, struct stat *buf);
int lstat(const char *path, struct stat *buf);

struct stat {
    dev_t st_dev; /* ID of device containing file */
    ino_t st_ino; /* inode number */
    mode_t st_mode; /* protection */
    nlink_t st_nlink; /* number of hard links */
    uid_t st_uid; /* user ID of owner */
    gid_t st_gid; /* group ID of owner */
    dev_t st_rdev; /* device ID (if special file) */
    off_t st_size; /* total size, in bytes */
    blksize_t st_blksize; /* blocksize for file system I/O */
    blkcnt_t st_blocks; /* number of 512B blocks allocated */
    time_t st_atime; /* time of last access */
    time_t st_mtime; /* time of last modification */
    time_t st_ctime; /* time of last status change */
};
```

stat既有命令也有同名函数，用来获取文件Inode里主要信息

stat 跟踪符号链接，lstat不跟踪符号链接

stat里面时间辨析：

- atime(最近访问时间)： 
- mtime(最近更改时间):指最近修改文件内容的时间
- ctime(最近改动时间)：指最近改动Inode的时间

## 二、access

```
#include <unistd.h>
int access(const char *pathname, int mode);
```

access 按实际用户ID和实际组ID测试,跟踪符号链接

参数mode：
- `R_OK` 是否有读权限
- `W_OK` 是否有写权限
- `X_OK` 是否有执行权限
- `F_OK` 测试一个文件是否存在

sudo 执行时，有效用户 ID 是root，实际用户 ID 是 xingwenpeng

## 一、chmod

```c
#include <sys/stat.h>
int chmod(const char *path, mode_t mode);
int fchmod(int fd, mode_t mode);
```


## 二、chown

```c
#include <unistd.h>
int chown(const char *path, uid_t owner, gid_t group);
int fchown(int fd, uid_t owner, gid_t group);
int lchown(const char *path, uid_t owner, gid_t group); //跟踪符号链接
```

chown 使用时必须拥有 root 权限


## 一、link

```
#include <unistd.h>
int link(const char *oldpath, const char *newpath);
```

link 创建一个硬链接，当 rm 删除文件时，只是删除了目录下的记录项和把 inode 硬链接计数减 1，当硬链接计数减为 0 时，才会真正的删除文件。

- 硬链接通常要求位于同一文件系统中,POSIX 允许跨文件系统
- 符号链接没有文件系统限制
- 通常不允许创建目录的硬链接，某些 unix 系统下超级用户可以创建目录的硬链接
- 创建目录项以及增加硬链接计数应当是一个原子操作

## 二、symlink

```
int symlink(const char *oldpath, const char *newpath)
```

symlink 创建一个软连接，即符号连接

## 三、readlink

```
ssize_t readlink(const char *path, char *buf, size_t bufsiz)
```

readlink 读符号链接所指向的文件名字，不读文件内容

## 四、unlink

```
int unlink(const char *pathname)
```

1. 如果是符号链接，删除符号链接
2. 如果是硬链接，硬链接数减 1，当减为 0 时，释放数据块和 inode
3. 如果文件硬链接数为 0，但有进程已打开该文件，并持有文件描述符，则等该进程关闭该文件时，kernel 才真正
去删除该文件
4. 利用该特性创建临时文件，先 open 或 creat 创建一个文件，马上 unlink 此文件

## 一、mkdir

```c
#include <sys/stat.h>
#include <sys/types.h>

int mkdir(const char *pathname, mode_t mode);
```

## 二、rmdir

```c
#include <unistd.h>

int rmdir(const char *pathname);
```

## 三、opendir、fdopendir

```c
#include <sys/types.h>
#include <dirent.h>

DIR *opendir(const char *name);
DIR *fdopendir(int fd);
```

## 四、readdir

```c
#include <dirent.h>

struct dirent *readdir(DIR *dirp);

struct dirent {
    ino_t d_ino; /* inode number */
    off_t d_off; /* offset to the next dirent */
    unsigned short d_reclen; /* length of this record */
    unsigned char d_type; /* type of file; not supported
    by all file system types */
    char d_name[256]; /* filename */
};
```

## 五、rewindir

rewindir 把目录指针恢复到目录的起始位置

```c
#include <sys/types.h>
#include <dirent.h>
void rewinddir(DIR *dirp);
```

## 六、telldir、seekdir

```
#include <dirent.h>
long telldir(DIR *dirp);

#include <dirent.h>
void seekdir(DIR *dirp, long offset);
```

## 七、closedir

```
#include <sys/types.h>
#include <dirent.h>
int closedir(DIR *dirp);
```

## 八、递归遍历目录

递归列出目录中的文件列表

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>
#include <stdio.h>
#include <string.h>

#define MAX_PATH 1024

/* dirwalk: apply fcn to all files in dir */
void dirwalk(char *dir, void (*fcn)(char *))
{
    char name[MAX_PATH];
    struct dirent *dp;
    DIR *dfd;
    if ((dfd = opendir(dir)) == NULL) {
        fprintf(stderr, "dirwalk: can't open %s\n", dir);
        return;
    }
    while ((dp = readdir(dfd)) != NULL) {
        if (strcmp(dp->d_name, ".") == 0
        || strcmp(dp->d_name, "..") == 0)
            continue; /* skip self and parent */
        if (strlen(dir)+strlen(dp->d_name)+2 > sizeof(name))
            fprintf(stderr, "dirwalk: name %s %s too long\n", dir, dp->d_name);
        else {
            sprintf(name, "%s/%s", dir, dp->d_name);
            (*fcn)(name);
        }
    }
    closedir(dfd);
}
/* fsize: print the size and name of file "name" */
void fsize(char *name)
{
    struct stat stbuf;
    if (stat(name, &stbuf) == -1) {
        fprintf(stderr, "fsize: can't access %s\n", name);
        return;
    }
    if ((stbuf.st_mode & S_IFMT) == S_IFDIR)
        dirwalk(name, fsize);
    printf("%8ld %s\n", stbuf.st_size, name);
}
int main(int argc, char **argv)
{
    if (argc == 1) /* default: current directory */
        fsize(".");
    else
        while (--argc > 0)
            fsize(*++argv);
    return 0;
}
```


缓冲IO
不带缓冲IO
阻塞IO
非阻塞IO
IO复用
信号驱动IO
异步IO

参考：

- 《APUE》第三、四章
