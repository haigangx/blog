# 文件操作总结

<!-- TOC -->

- [一、原理](#一原理)
    - [1. Linux 文件系统](#1-linux-文件系统)
    - [2. 内核管理打开文件模型](#2-内核管理打开文件模型)
    - [3. 文件 I/O 缓冲](#3-文件-io-缓冲)
- [二. 文件 I/O](#二-文件-io)
    - [1. 带缓冲 I/O 和不带缓冲 I/O](#1-带缓冲-io-和不带缓冲-io)
        - [1.1 open](#11-open)
        - [二、umask 掩码](#二umask-掩码)
        - [三、最大打开文件个数](#三最大打开文件个数)
        - [四、close](#四close)
        - [一、read](#一read)
        - [二、write](#二write)
        - [三、阻塞和非阻塞](#三阻塞和非阻塞)
    - [1. 阻塞](#1-阻塞)
        - [1.1 阻塞读终端](#11-阻塞读终端)
    - [2. 非阻塞](#2-非阻塞)
        - [2.1 非阻塞读终端](#21-非阻塞读终端)
- [一、lseek](#一lseek)
- [二、lseek 的更多用处](#二lseek-的更多用处)
- [一、stat](#一stat)
- [二、access](#二access)
- [一、chmod](#一chmod)
- [二、chown](#二chown)

<!-- /TOC -->

## 一、原理

### 1. Linux 文件系统

更详细的 [Linux文件系统描述]()

把一个磁盘分成一个或多个分区，每个分区可以包含一个文件系统，下图是一个典型的 Linux 文件系统：

<div align="center"><img src="doc/磁盘分区和文件系统.png" width="700"></img></div>


图中 i 节点是固定长度的记录项，其中包含了有关文件的大部分信息，下图描述了 i 节点、数据块、目录块之间的关系：

<div align="center"><img src="doc/较详细的柱面组的i节点和数据块.png" width="700"></img></div>

可以发现：

1. 图中有两个目录项指向同一个 i 节点，每个 i 节点都有一个链接计数，其值是指向该 i 节点的目录项数，只有当链接数减少为 0 时，才可删除该文件（也就是可以释放该文件所占的数据块），因此删除一个目录项的函数被称为 unlink 而不是 delete，在 stat 结构中，链接计数包含在 `st_nlink` 成员中，其基本系统数据类型为 nlink_t，这种链接称为 **硬链接**，常量 `LINK_MAX` 指定了一个文件链接数的最大值

2. 另一种链接类型为 **符号链接（symbolic link）**，符号链接文件的实际内容（在数据块中）包含了该符号链接所指向的文件的名字，所以符号链接可以跨文件系统，符号链接文件的 i 节点中的文件类型为 S_IFLNK

3. i 节点中包含了文件有关的所有信息：文件类型、文件访问权限位、文件长度、指向文件实际数据块的指针等，stat 结构的大多数信息都取自 i 节点，只有两项重要数据放在目录项中：文件名和 i 节点编号

4. 因为目录项中的 i 节点编号指向同一文件系统中相应 i 节点，所以一个目录项不能指向另一个文件系统的 i 节点，这也是硬链接不能跨文件系统的原因

5. 当在不更换文件系统的情况下为一个文件重命名时，该文件的实际内容并未移动，只需构造一个指向现有 i 节点的新目录项，并删除老的目录项，链接计数不会改变

6. 任何一个叶目录（不包含其他目录的目录）的链接计数总是 2，数值 2 来自于命名该目录的的目录项以及在该目录中的 `.` 项

   以创建新目录 testdir 为例：`mkdir testdir`，下图为创建了目录 testdir 后的文件系统结构：

   <div align="center"><img src="doc/创建了目录testdir后的文件系统实例.png" width="700"></img></div>

   - 编号为 2549 的 i 节点，其类型字段表示其为目录，其链接计数为 2，分别来自本目录的 `.` 项以及父目录中的目录项，从父目录的目录项可以看出该目录名为 testdir
   - 编号为 1267 的 i 节点，其类型字段表示其为目录，其链接计数至少为 3，一个是命名它的父目录的目录项，第二个是在该目录的 `.` 项，第三个是其子目录 testdir 的 `..` 项

### 2. 内核管理打开文件模型

对于内核而言，所有打开的文件都通过文件描述符引用，文件描述符是一个非负整数，当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。读写操作文件都通过操作该文件描述符完成。

- 每个进程在内核进程表中都有一个记录项，记录项中包含一张打开文件描述符表，每个打开的文件描述符占用一项，与每个文件描述符相关联的是：

  1. 文件描述符状态（close_on_exec）
  2. 指向一个文件表项的指针

- 内核为所有打开文件维持一张文件表，每个文件表项包含：

  1. 文件状态标志（读、写、追加、同步、非阻塞等）
  2. 当前文件偏移量
  3. 指向该文件 v 节点表项的指针

- 每个打开文件（或设备）都有一个 v 节点（v-node）结构。v 节点包含了文件类型和对此文件进行各种操作函数的指针，对于大多数文件，v 节点还包含了该文件的 i 节点(i-node，索引节点)，i 节点中包含了文件的所有者、文件长度、文件实际数据块指针等，这些信息是在打开文件时从磁盘读入内存的，所以

每当运行一个新程序时，系统为其打开 3 个文件描述符，即标准输入（STDIN_FILENO, 0）、标准输出（STDOUT_FILENO, 1）、标准错误（STDERR_FILENO, 2），文件描述符的变化范围为 `0~OPEN_MAX-1`

<div align="center"><img src="doc/打开文件的内核数据结构.png" width="700"></img></div>

当两个独立进程打开同一个文件，每个进程都有各自的文件表项，但是一个打开只有一个 v 节点表项。这样每个进程都有自己对该文件的当前偏移量和文件打开状态

<div align="center"><img src="doc/两个独立进程各自打开同一个文件.png" width="700"></img></div>

可能有多个文件描述符指向同一个文件表项：

1. 使用 `dup` 函数
2. `fork` 之后，父进程、子进程各自的每一个打开文件描述符共享同一个文件表项

文件描述符标志和文件状态标志在作用范围方面有区别：前者只用于一个进程的一个描述符，后者则应用于指向给定文件表项的任何进程的所有描述符

### 3. 文件 I/O 缓冲

## 二. 文件 I/O

### 1. 带缓冲 I/O 和不带缓冲 I/O

#### 1.1 open

```
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
```

- `pathname` 参数是要打开或创建的文件名，既可以是相对路径也可以是绝对路径
- `flags` 参数有一系列常数值可供选择，可以同时选择多个常数用按位或运算符连接起来，所以这些常数的宏定义都以 O_开头，表示 or

  有三个必选项：以下三个常数中必须指定一个，且仅允许指定一个

  1. `O_RDONLY` 只读打开
  2. `O_WRONLY` 只写打开
  3. `O_RDWR` 可读可写打开

  以下可选项可以同时指定 0 个或多个，和必选项按位或起来作为 flags 参数。可选项有很多，这里只介绍一部分，其它选项可参考 `open(2)` 的 Man Page：

  - `O_APPEND` 表示追加。如果文件已有内容，这次打开文件所写的数据附加到文件的末尾而不覆盖原来的内容
  - `O_CREAT` 若此文件不存在则创建它。使用此选项时需要提供第三个参数 mode，表示该文件的访问权限
  - `O_EXCL` 如果同时指定了 O_CREAT，并且文件已存在，则出错返回
  - `O_TRUNC` 如果文件已存在，并且以只写或可读可写方式打开，则将其长度截断（Truncate）为 0 字节
  - `O_NONBLOCK` 对于设备文件，以 O_NONBLOCK 方式打开可以做非阻塞 I/O（Nonblock I/O），非阻塞 I/O 在下一节详细讲解
  - `O_CLOEXEC` 

- `mode` 参数指定文件权限，可以用八进制数表示，比如 0644 表示 -rw-r-r–，也可以用 S_IRUSR、S_IWUSR 等宏定义按位或起来表示，详见 open(2) 的 Man Page。要注意的是，文件权限由 open 的 mode 参数和当前进程的 umask 掩码共同决定。

- 返回值：成功返回新分配的文件描述符，出错返回 -1 并设置 errno

一个进程默认打开 3 个文件描述符：

1. `STDIN_FILENO 0`
2. `STDOUT_FILENO 1`
3. `STDERR_FILENO 2`

新打开文件总是返回文件描述符表中未使用的最小文件描述符。

#### 二、umask 掩码

真正创建出来的文件权限是由设置权限 `&~` umask 掩码得来的

Shell进程的umask掩码可以用umask命令查看：

```
$ umask
0002
```

用 touch 命令创建一个文件时，创建权限是 0666，而 touch 进程继承了 Shell 进程的 umask 掩码，所以最终的文件权限是 0666 &~ 022=0644

```
$ touch file123
$ ls -l file123
-rw-rw-r-- 1 xingwenpeng xingwenpeng 0 9月11 23:48 file123
```

可以把 Shell 进程的 umask 改成 0 来证明 touch 创建文件的权限本来应该是 0666

```
$ rm file123
$ umask 0
$ touch file123
$ ls -l file123
-rw-rw-rw- 1 xingwenpeng xingwenpeng 0 9月11 23:52 file123
```

#### 三、最大打开文件个数

查看当前系统允许打开最大文件个数（硬限制）：

```
cat /proc/sys/fs/file-max
```

当前默认设置最大打开文件个数 1024（软限制）：

```
ulimit -a
```

修改默认设置最大打开文件个数为 4096：

```
ulimit -n 4096
```

#### 四、close

```
#include <unistd.h>
int close(int fd);
```
- 参数 fd 是要关闭的文件描述符
- 返回值：成功返回 0，出错返回 -1 并设置 errno


#### 一、read

```c
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);
```

- `fd` 是要读的文件或设备
- `count` 是请求读取的字节数，读上来的数据保存在缓冲区 `buf` 中，同时文件的当前读写位置向后移
- 返回值：成功返回读取的字节数，出错返回 -1 并设置 errno，如果在调 read 之前已到达文件末尾，则这次 read 返回 0

#### 二、write

```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);
```

- 返回值：成功返回写入的字节数，出错返回 -1 并设置 errno

#### 三、阻塞和非阻塞

### 1. 阻塞

阻塞（Block）即当进程调用一个阻塞的系统函数时，该进程被置于睡眠（Sleep）状态，这时内核调度其它进程运行，直到该进程等待的事件发生了（比如网络上接收到数据包，或者调用sleep指定的睡眠时间到了）它才有可能继续运行。

读/写常规文件是不会阻塞的，不管读多少字节，read 一定会在有限的时间内返回。而从终端设备或网络读则不一定，如果从终端输入的数据没有换行符，调用 read 读终端设备就会阻塞，如果网络上没有接收到数据包，调用 read 从网络读就会阻塞，至于会阻塞多长时间也是不确定的，如果一直没有数据到达就一直阻塞在那里。

#### 1.1 阻塞读终端

```c
#include <unistd.h>
#include <stdlib.h>

int main(void)
{
    char buf[10];
    int n;
    n = read(STDIN_FILENO, buf, 10);
    if (n < 0) {
        perror("read STDIN_FILENO");
        exit(1);
    }

    write(STDOUT_FILENO, buf, n);
    return 0;
}
```

执行结果：

```
$ ./a.out
hello（回车）
hello

$ ./a.out
hello world（回车）
hello worl$ d
bash: d: command not found
```

第一次执行 a.out 的结果很正常，而第二次执行的过程有点特殊，现在分析一下： 

a.out 调用 read 时睡眠等待，直到终端设备输入了换行符才从 read 返回，read 只读走 10 个字符，剩下的字符仍然保存在内核的终端设备输入缓冲区中。a.out 进程打印并退出，这时 Shell 进程恢复运行，Shell 继续从终端读取用户输入的命令，于是读走了终端设备输入缓冲区中剩下的字符 d 和换行符，把它当成一条命令解释执行，结果发现执行不了，没有 d 这个命令。

### 2. 非阻塞


如果在open一个设备时指定了O_NONBLOCK标志，read/write就不会阻塞。

以read为例，如果设备暂时没有数据可读就返回-1，同时置errno为EWOULDBLOCK（或者EAGAIN，这两个宏定义的值相同），表示本来应该阻塞在这里（would block，虚拟语气），事实上并没有阻塞而是直接返回错误，调用者应该试着再读一次（again）。这种行为方式称为轮询（Poll），调用者只是查询一下，而不是阻塞在这里死等，这样可以同时监视多个设备：

```
while(1) {
    非阻塞read(设备1);
    if(设备1有数据到达)
        处理数据;
    非阻塞read(设备2);
    if(设备2有数据到达)
        处理数据;
    ...
}
```

后面可以通过 IO 服用函数来管理非阻塞 IO

#### 2.1 非阻塞读终端

```c
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>

#define MSG_TRY "try again\n"

int main(void)
{
    char buf[10];
    int fd, n;
    fd = open("/dev/tty", O_RDONLY|O_NONBLOCK);
    if(fd<0) {
        perror("open /dev/tty");
        exit(1);
    }
    tryagain:
    n = read(fd, buf, 10);
    if (n < 0) {
        if (errno == EAGAIN) {
            sleep(1);
            write(STDOUT_FILENO, MSG_TRY, strlen(MSG_TRY));
            goto tryagain;
        }
        perror("read /dev/tty");
        exit(1);
    }
    write(STDOUT_FILENO, buf, n);
    close(fd);
    return 0;
}
```

# 文件定位 lseek

## 一、lseek

每个打开的文件都记录着当前读写位置：

- 通常打开文件时读写位置是 0，表示文件开头，通常读写多少个字节就会将读写位置往后移多少个字节。
- 如果以 O_APPEND 方式打开，每次写操作都会在文件末尾追加数据，然后将读写位置移到新的文件末尾

lseek 可以手动移动当前读写位置：

```
#include <sys/types.h>
#include <unistd.h>

off_t lseek(int fd, off_t offset, int whence);
```

- `fd` 打开文件的文件描述符
- `offset` off_t 类型的偏移量，off_t 一般为整型类型
- `whence` 可以取以下三个值之一：

   1. `SEEK_SET` 设置文件读写位置为 offset
   2. `SEEK_CUR` 设置文件读写位置为当前位置 +offset
   3. `SEEK_END` 设置文件读写位置为文件大小 +offset

- 返回值：成功返回新的偏移量，失败返回 -1 并设置 errno
  - 如果设备不支持 lseek，errno 将设置为 ESPIPE

## 二、lseek 的更多用处

- 当设置的读写位置超过文件末尾时，lseek 将拓展文件，其中拓展出来的部分都是 0
- 可以通过 lseek 确定一个打开文件的当前偏移量：

  ```c
  off_t currpos;
  currpos = lseek(fd, 0, SEEK_CUR);
  ```

# 获取文件信息 stat

<!-- TOC -->

- [一、stat](#一stat)
- [二、access](#二access)

<!-- /TOC -->

## 一、stat

```
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int stat(const char *path, struct stat *buf);
int fstat(int fd, struct stat *buf);
int lstat(const char *path, struct stat *buf);

struct stat {
    dev_t st_dev; /* ID of device containing file */
    ino_t st_ino; /* inode number */
    mode_t st_mode; /* protection */
    nlink_t st_nlink; /* number of hard links */
    uid_t st_uid; /* user ID of owner */
    gid_t st_gid; /* group ID of owner */
    dev_t st_rdev; /* device ID (if special file) */
    off_t st_size; /* total size, in bytes */
    blksize_t st_blksize; /* blocksize for file system I/O */
    blkcnt_t st_blocks; /* number of 512B blocks allocated */
    time_t st_atime; /* time of last access */
    time_t st_mtime; /* time of last modification */
    time_t st_ctime; /* time of last status change */
};
```

stat既有命令也有同名函数，用来获取文件Inode里主要信息

stat 跟踪符号链接，lstat不跟踪符号链接

stat里面时间辨析：

- atime(最近访问时间)： 
- mtime(最近更改时间):指最近修改文件内容的时间
- ctime(最近改动时间)：指最近改动Inode的时间

## 二、access

```
#include <unistd.h>
int access(const char *pathname, int mode);
```

access 按实际用户ID和实际组ID测试,跟踪符号链接

参数mode：
- `R_OK` 是否有读权限
- `W_OK` 是否有写权限
- `X_OK` 是否有执行权限
- `F_OK` 测试一个文件是否存在

sudo 执行时，有效用户 ID 是root，实际用户 ID 是 xingwenpeng

## 一、chmod

```c
#include <sys/stat.h>
int chmod(const char *path, mode_t mode);
int fchmod(int fd, mode_t mode);
```


## 二、chown

```c
#include <unistd.h>
int chown(const char *path, uid_t owner, gid_t group);
int fchown(int fd, uid_t owner, gid_t group);
int lchown(const char *path, uid_t owner, gid_t group); //跟踪符号链接
```

chown 使用时必须拥有 root 权限


# 文件链接

## 一、link

```
#include <unistd.h>
int link(const char *oldpath, const char *newpath);
```

link 创建一个硬链接，当 rm 删除文件时，只是删除了目录下的记录项和把 inode 硬链接计数减 1，当硬链接计数减为 0 时，才会真正的删除文件。

- 硬链接通常要求位于同一文件系统中,POSIX 允许跨文件系统
- 符号链接没有文件系统限制
- 通常不允许创建目录的硬链接，某些 unix 系统下超级用户可以创建目录的硬链接
- 创建目录项以及增加硬链接计数应当是一个原子操作

## 二、symlink

```
int symlink(const char *oldpath, const char *newpath)
```

symlink 创建一个软连接，即符号连接

## 三、readlink

```
ssize_t readlink(const char *path, char *buf, size_t bufsiz)
```

readlink 读符号链接所指向的文件名字，不读文件内容

## 四、unlink

```
int unlink(const char *pathname)
```

1. 如果是符号链接，删除符号链接
2. 如果是硬链接，硬链接数减 1，当减为 0 时，释放数据块和 inode
3. 如果文件硬链接数为 0，但有进程已打开该文件，并持有文件描述符，则等该进程关闭该文件时，kernel 才真正
去删除该文件
4. 利用该特性创建临时文件，先 open 或 creat 创建一个文件，马上 unlink 此文件

# 目录操作

## 一、mkdir

```c
#include <sys/stat.h>
#include <sys/types.h>

int mkdir(const char *pathname, mode_t mode);
```

## 二、rmdir

```c
#include <unistd.h>

int rmdir(const char *pathname);
```

## 三、opendir、fdopendir

```c
#include <sys/types.h>
#include <dirent.h>

DIR *opendir(const char *name);
DIR *fdopendir(int fd);
```

## 四、readdir

```c
#include <dirent.h>

struct dirent *readdir(DIR *dirp);

struct dirent {
    ino_t d_ino; /* inode number */
    off_t d_off; /* offset to the next dirent */
    unsigned short d_reclen; /* length of this record */
    unsigned char d_type; /* type of file; not supported
    by all file system types */
    char d_name[256]; /* filename */
};
```

## 五、rewindir

rewindir 把目录指针恢复到目录的起始位置

```c
#include <sys/types.h>
#include <dirent.h>
void rewinddir(DIR *dirp);
```

## 六、telldir、seekdir

```
#include <dirent.h>
long telldir(DIR *dirp);

#include <dirent.h>
void seekdir(DIR *dirp, long offset);
```

## 七、closedir

```
#include <sys/types.h>
#include <dirent.h>
int closedir(DIR *dirp);
```

## 八、递归遍历目录

递归列出目录中的文件列表

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>
#include <stdio.h>
#include <string.h>

#define MAX_PATH 1024

/* dirwalk: apply fcn to all files in dir */
void dirwalk(char *dir, void (*fcn)(char *))
{
    char name[MAX_PATH];
    struct dirent *dp;
    DIR *dfd;
    if ((dfd = opendir(dir)) == NULL) {
        fprintf(stderr, "dirwalk: can't open %s\n", dir);
        return;
    }
    while ((dp = readdir(dfd)) != NULL) {
        if (strcmp(dp->d_name, ".") == 0
        || strcmp(dp->d_name, "..") == 0)
            continue; /* skip self and parent */
        if (strlen(dir)+strlen(dp->d_name)+2 > sizeof(name))
            fprintf(stderr, "dirwalk: name %s %s too long\n", dir, dp->d_name);
        else {
            sprintf(name, "%s/%s", dir, dp->d_name);
            (*fcn)(name);
        }
    }
    closedir(dfd);
}
/* fsize: print the size and name of file "name" */
void fsize(char *name)
{
    struct stat stbuf;
    if (stat(name, &stbuf) == -1) {
        fprintf(stderr, "fsize: can't access %s\n", name);
        return;
    }
    if ((stbuf.st_mode & S_IFMT) == S_IFDIR)
        dirwalk(name, fsize);
    printf("%8ld %s\n", stbuf.st_size, name);
}
int main(int argc, char **argv)
{
    if (argc == 1) /* default: current directory */
        fsize(".");
    else
        while (--argc > 0)
            fsize(*++argv);
    return 0;
}
```


缓冲IO
不带缓冲IO
阻塞IO
非阻塞IO
IO复用
信号驱动IO
异步IO

参考：

- 《APUE》第三、四章
