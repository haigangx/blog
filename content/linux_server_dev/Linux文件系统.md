# Linux 文件系统

<!-- TOC -->

- [一、文件系统特性](#一文件系统特性)
    - [1. 索引式文件系统](#1-索引式文件系统)
    - [2. 顺序式文件系统](#2-顺序式文件系统)
- [二、Linux 的 ext2 文件系统](#二linux-的-ext2-文件系统)
    - [1. 超级块(Super Block)](#1-超级块super-block)
    - [2. 块组描述符表(GDT, Group Descriptor Table)](#2-块组描述符表gdt-group-descriptor-table)
    - [4. 块位图(Block Bitmap)](#4-块位图block-bitmap)
    - [5. inode 位图(inode Bitmap)](#5-inode-位图inode-bitmap)
    - [6. inode 表(inode Table)](#6-inode-表inode-table)
    - [7. 数据块(Data Block)](#7-数据块data-block)
- [三、使用 dumpe2fs 观察 Linux 文件系统](#三使用-dumpe2fs-观察-linux-文件系统)

<!-- /TOC -->

## 一、文件系统特性

我们都知道磁盘分区完毕后要进行 **格式化(format)** 后操作系统才能够使用这个分区。 为什么需要进行格式化呢？其实格式化即是将这个分区初始化为当前操作系统所能识别的文件系统格式

文件系统除了管理文件实际内容外，还需要管理很多文件属性，如：文件权限(rwx)与文件属性（拥有者、群组、时间）等，文件系统通常会将这两部分数据存放在不同的区块：

- 权限与属性放置到 inode 中
- 实际数据则放置到 datablock 区块中 

当然，还有许多其他区块用来记录文件系统的其他信息，这个后面再说明

每个 inode 与 block 都有编号，这两个数据的意义可以简略说明如下：

- inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block 号码；
- block：实际记录文件的内容，若文件太大时，会占用多个 block 。

### 1. 索引式文件系统

由于每个 inode 与 block 都有编号，而每个文件都会占用一个 inode ，inode 内则有文件数据放置的 block 号码。 因此，如果能够找到文件的 inode 的话，就能直到这个文件所放置数据的 block 号码， 就能读出该文件的实际数据了。

这是个比较有效率的作法，因为磁盘就能够在短时间内读取出文件的全部数据

将 inode 与 block 区块用图解来说明一下，如下图所示，文件系统先格式化出 inode 与 block 的区块，假设某一个文件的属性与权限数据是放置到 inode 4 号(下图较小方格内)，而这个 inode 记录了文件数据的实际放置点为 2, 7, 13, 15 这四个 block 号码，此时我们的操作系统就能够据此来排列磁盘的阅读顺序，可以一口气将四个 block 内容读出来！ 那么数据的读取就如同下图中的箭头所指定的模样了。

<div align="center"><image src="../doc/索引式文件系统图示.jpg"></image></div>

这种数据存取的方式为 **索引式文件系统(indexed allocation)**

### 2. 顺序式文件系统

与索引式相对于的是 **顺序式文件系统**，以 FAT 文件系统为例：FAT 这种格式的文件系统并没有 inode 存在，所以 FAT 没有办法将这个文件的所有 block 在一开始就读取出来。每个 block 号码都记录在前一个 block 当中， 他的读取方式有点像底下这样：

<div align="center"><image src="../doc/顺序式文件系统.jpg"></image></div>

上图中我们假设文件的数据依序写入 1->7->4->15 号这四个 block 号码中， 但这个文件系统没有办法一口气就知道四个 block 的号码，他得要一个一个的将 block 读出后，才会知道下一个 block 在何处。 如果同一个文件数据写入的 block 分散的太过厉害时，则我们的磁盘读取头将无法在磁盘转一圈就读到所有的数据， 因此磁盘就会多转好几圈才能完整的读取到这个文件的内容！

> 有些文件系统需要碎片整理的原因就是文件写入的 block 太过于离散了，此时文件读取的效能将会变的很差。 这个时候可以透过碎片整理将同一个文件所属的 blocks 汇整在一起，使数据读写更容易 


## 二、Linux 的 ext2 文件系统


以 ext2 文件系统说明 Linux 文件系统的结构：

<div align="center"><image src="../doc/ext2文件系统.png"></image></div>

上图是一个磁盘分区格式化为 ext2 文件系统后的存储布局：

文件系统中存储的最小单位是 **块**，其大小在格式化时确定的，可以通过 `mke2fs` 的 `-b` 选项设定初始化时块大小为1024、2048 或 4096 字节

其中 **启动块（Boot Block）** 的大小是确定的，就是1KB，启动块是由PC标准规定的，用来存储磁盘分区信息和启动信息，任何文件系统都不能使用启动块，启动块之后才是ext2文件系统的开始。

ext2文件系统将整个分区划成若干个同样大小的块组（Block Group），每个块组都由以下部分组成：


### 1. 超级块(Super Block)

描述整个分区的文件系统信息，例如块大小、文件系统版本号、上次mount的时间等等。超级块在每个块组的开头都有一份拷贝

### 2. 块组描述符表(GDT, Group Descriptor Table)

由很多块组描述符组成，整个分区分
成多少个块组就对应有多少个块组描述符。每个块组描述符（Group Descriptor）存储一个
块组的描述信息，例如在这个块组中从哪里开始是inode表，从哪里开始是数据块，空闲的
inode和数据块还有多少个等等。和超级块类似，块组描述符表在每个块组的开头也都有一
份拷贝，这些信息是非常重要的，一旦超级块意外损坏就会丢失整个分区的数据，一旦块组
描述符意外损坏就会丢失整个块组的数据，因此它们都有多份拷贝。通常内核只用到第0个
块组中的拷贝，当执行e2fsck检查文件系统一致性时，第0个块组中的超级块和块组描述符
表就会拷贝到其它块组，这样当第0个块组的开头意外损坏时就可以用其它拷贝来恢复，从
而减少损失。

### 4. 块位图(Block Bitmap)

### 5. inode 位图(inode Bitmap)


### 6. inode 表(inode Table)

### 7. 数据块(Data Block)

data block 是用来放置文件内容数据的地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种，且在初始化时就已经固定了，每个 block 都有编号，以方便 inode 的记录 

由于 block 大小的差异，会导致该文件系统能够支持的最大磁盘容量与最大单一文件容量并不相同。 因为 block 大小而产生的 Ext2 文件系统限制如下：

| Block 大小 | 1 KB | 2 KB | 4 KB |
| --- | --- | --- | --- |
| 最大单一文件限制 | 16 GB | 256 GB | 2 TB |
| 最大文件系统总容量 | 2 TB | 8 TB | 16 TB |



## 三、使用 dumpe2fs 观察 Linux 文件系统

