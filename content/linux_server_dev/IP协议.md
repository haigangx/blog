# IP协议

<!-- TOC -->

- [一、IP 协议简介](#一ip-协议简介)
- [二、IP 协议特点](#二ip-协议特点)
    - [1. 无状态](#1-无状态)
    - [2. 无连接](#2-无连接)
    - [3. 不可靠](#3-不可靠)
- [三、IPv4 头部结构](#三ipv4-头部结构)
- [四、使用 tcpdump 观察 IPv4 头部结构](#四使用-tcpdump-观察-ipv4-头部结构)
- [五、IP 分片](#五ip-分片)
    - [1. 为什么要分片？](#1-为什么要分片)
    - [2. 如何实现分片和重组？](#2-如何实现分片和重组)
    - [3. 使用 tcpdump 观察 IP 分片](#3-使用-tcpdump-观察-ip-分片)
- [六、IP 路由](#六ip-路由)
    - [1. IP 模块工作流程](#1-ip-模块工作流程)
    - [2. 路由机制](#2-路由机制)
    - [3. 使用 route 修改路由表](#3-使用-route-修改路由表)
    - [4. IP 转发](#4-ip-转发)

<!-- /TOC -->

## 一、IP 协议简介

IP 协议是 TCP/IP 协议族的核心协议，IP 协议部分的知识主要包括两方面：

- **IP 头部信息：**

  IP 头部信息出现在每个 IP 数据报中，用于指定 IP 通信的源端 IP 地址、目的端 IP 地址，指导 IP 分片和重组，以及指定部分通信行为

- **IP 数据报的路由和转发过程：**
 
  IP 数据报的路由和转发发生在除目标机器之外的所有主机和路由器上，它们决定了数据报是否应该转发及如何被转发



## 二、IP 协议特点

IP 协议是 TCP/IP 协议族的动力，它为上层协议提供 **无状态、无连接、不可靠** 的服务

### 1. 无状态

无状态是指：IP 通信双方不同步传输数据的状态信息，因此所有 IP 数据报的发送、传输、接收都是相互独立、没有上下文关系的。

- 无状态服务的 **最大缺点就是无法处理乱序和重复的IP数据报**

  比如发送端发送出的第 N 个 IP 数据报可能比第 N+1 个 IP 数据报后到达接收端，而同一个 IP 数据报也可能经过不同的路径多次到达接收端；
  
  上面这两种情况下，接收端的 IP 模块无法检测到乱序和重复，因此这些 IP 数据报之间没有任何上下文关系。接收端的 IP 模块只要收到了完整的 IP 数据报（如果是 IP 分片，先将分片重组为完整的数据报），就将其数据部分（TCP报文段、UDP数据报、ICMP报文）上交给上层协议，从上层协议来看，这些数据可能是乱序的、重复的。

  面向连接的协议，如 TCP 协议，则能够自己处理乱序的、重复的报文段，它递交给上层协议的内容绝对是有序的、正确的

  IP 数据报头部的 16 位标识字段用以唯一标识一个 IP 数据报，但是它是用来处理 IP 分片和重组的，而不是用来指示接收顺序的


- 无状态服务的 **优点就是简单、高效**

  无须为保持通信的状态而分配一些内核资源，也无须每次传输数据时都携带状态信息


### 2. 无连接

无连接是指：IP 通信双方都不长久地维持对方的任何信息

这样，上层协议每次发送数据的都是，都必须明确指定对方的 IP 地址

### 3. 不可靠

不可靠是指：IP 协议不能保证 IP 数据报准确地到达接收端，它只是承诺尽最大努力(best offort)

有很多种情况会导致 IP 数据报发送失败，如：

- **TTL** 判断：某个中转路由器发现 IP 数据报在网络上存活的时间太长了，那么它将丢弃之，并返回一个 ICMP 错误消息（超时消息）给发送端
- 接收端收到的 IP 数据报不正确（**不能通过校验机制**），它将其丢弃之，并返回一个 ICMP错误消息（IP 头部参数错误）给发送端

发送端的 IP 模块一旦检测到 IP 数据报发送失败，就通知上层协议发送失败，而不会试图重传，使用 IP 服务的上层协议，如 TCP 协议，就需要自己实现 **数据确认、超时重传** 等机制以达到可靠传输的目的

## 三、IPv4 头部结构

IPv4 头部结构如下，其长度通常为 20 字节，除非含有可变长的选项部分

<div align="center"><image src="../doc/IPv4头部结构.png"></image></div>

- `4 位版本号` 指定 IP 协议的版本，对 IPv4 来说，其值为 4。其他 IPv4 协议的拓展版本，则具有不同的版本号
- `4 位头部长度` 标识该 IP 头部有多少个 32 bit位（即 4 字节），由于 4 位最大能表示 15，所以 IP 头部最长是 60 字节
- `8 位服务类型(TOS)` 包括一个 3 位的优先权字段（现已被忽略），4 位的 TOS 字段和 1 位 保留字段（必须置 0）
   
   - 4 位的 TOS 字段分别表示：最小延时、最大吞吐量、最高可靠性、最小费用。其中最多有一个能置 1 ，应用程序根据实际需要设置。如像 ssh 和 telnet 这样的登录程序需要的是最小延时服务，而文件传输程序 ftp 则需要最大吞吐量的服务

- `16 位总长度` 指整个 IP 数据报的长度，以字节为单位

  因此，IP 数据报的最大长度为 65535(2<sup>16</sup>-1) 字节。但由于 MTU 的限制，长度超过 MTU 的数据报都将被分片传输，所以实际传输的 IP 数据报的长度都远远没有达到最大值

- `16 位标识` 唯一地标识主机发送的每一个数据报。

  其初始值由系统随机生成，每发送一个数据报，其值就加 1。该值在数据报分片时被复制到每个分片中。因此，同一个数据报的所有分片都具有相同的标识值

- `3 位标志字段` 

  - 第一位保留
  - 第二位（Don't Fragment, DF）表示“禁止分片”。如果设置了该位，IP 模块将不对数据报分片。这时，如果 IP 数据报长度超过 MTU 的话，IP 模块将丢弃该数据报并返回一个 ICMP 差错报文
  - 第三位（More Fragment, MF）表示“更多分片”。除了数据报的最后一个分片外，其他分片都要把它置为 1

- `13 位分片偏移` 是分片相对原始 IP 数据报开始处（仅指数据部分）的偏移。
  
  实际的偏移值是该值左移 3 位（乘 8）后得到的。由于这个原因，除了最后一个 IP 分片外，每个 IP 分片的数据部分的长度都必须是 8 的整数倍（这样才能保证后面的 IP 分片拥有一个合适的偏移值）

- `8 位生存时间 TTL` 是数据报到达目的地之前允许经过的路由器跳数。
  
  TTL 值被发送端设置（常见值为 64）.数据报在转发过程中每经过一个路由，该值就被路由器减 1。当 TTL 值减为 0 时，路由器将丢弃数据报，并向源端发送一个 ICMP 差错报文，TTL 值可以防止数据报陷入路由循环

- `8 位协议` 用来区分上层协议

  `/etc/protocols` 文件中定义了所有上层协议对应的 protocol 字段的数值，其中：ICMP 是 1，TCP 是 6，UDP 是 17

- `16 位头部校验和` 由发送端填充，接收端对其使用 CRC 算法以检验 IP 数据报头部（仅检验头部）在传输过程中是否损坏

- `32 位源端 IP 地址` 和 `32 位目的端 IP 地址` 分别用来标识数据报的发送端和接收端

  一般来说，这两个地址在整个数据报的传递过程中保持不变，而不论它中间经过多少个中转路由器

- `IPv4 最后一个选项字段` 是可变长的可选信息，这部分最多包含 40 字节，因为 IP 头部最长是 60 字节（包括前面 20 字节的固定部分），可用的 IP 选项包括：

  - `记录路由(record route)`：告诉数据报途径的所有路由器都将自己的 IP 地址填入 IP 头部的选项部分，这样就可以跟踪数据报的传递路径
  - `时间戳(timestamp)`：告诉每个路由器都将数据报被转发的时间（或时间与IP地址对）填入 IP 头部的选项部分，这样就可以测量途径路由之间数据报传输的时间
  - `松散源路由选择(loose source routing)`：指定一个路由表 IP 地址列表，数据报发送过程中必须经过其中所有的路由器
  - `严格源路由选择(strict source routing)`：指定一个路由表 IP 地址列表，数据报只能经过被指定的路由器


## 四、使用 tcpdump 观察 IPv4 头部结构

我们在本地机器上执行 `telnet` 命令登录本机，并用 `tcpdump` 抓取这个过程中 telnet 客户端和 telnet 服务器之间交换的数据包

打开终端，使用 `tcpdump` 抓取本地回路上的数据包（telnet服务器端口号23）

```
sudo tcpdump -ntx -i lo port 23
```

重新打开一个终端，使用 `telnet` 登录本机（登录失败不影响）

```
telnet 127.0.0.1
```

此时观察 `tcpdump` 输出的第一个数据包，其内容如下：

```
IP 127.0.0.1.38560 > 127.0.0.1.23: Flags [S], seq 4242890062, win 65495, options [mss 65495,sackOK,TS val 3913303147 ecr 0,nop,wscale 7], length 0                                                                
        0x0000:  4510 003c ca49 4000 4006 7260 7f00 0001                                                 
        0x0010:  7f00 0001 96a0 0017 fce5 5d4e 0000 0000                                                 
        0x0020:  a002 ffd7 fe30 0000 0204 ffd7 0402 080a                                                 
        0x0030:  e940 446b 0000 0000 0103 0307
```

- 该数据包描述的是一个 `IP` 数据报
- 由于使用 telnet 登录本机，所以 IP 数据报的源端 IP 地址和目的端 IP 地址都是 `127.0.0.1`
- telnet 服务器程序使用端口号是 `23`，telnet 客户端程序使用临时端口号 `38560` 与服务器通信
- `Flags`、`seq`、`win`、`options`等描述的都是 TCP 头部信息
- `length` 指出该 IP 数据报所携带的应用程序数据长度

由于开启了 `tcpdump -x` 选项，使之输出了数据报的二进制码。此数据包共包含 60 字节，其中前 20 字节是 IP 头部，后 40 字节是 TCP 头部，不包含应用程序数据（length 为 0）

对 20 字节的 IP 头部 `4510 003c ca49 4000 4006 7260 7f00 0001 7f00 0001` 分析如下表：

| 十六进制数 | 十进制表示 | IP 头部信息 |
| --- | --- | --- |
| 0x4 | 4 | 4 位 IP 版本号 |
| 0x5 | 5 | 4 位头部长度，长度为 5 个 32 位(4 字节)即 20 字节 |
| 0x10 |  | 8 位 TOS， 选项中最小延时服务被开启 |
| 0x003c | 60 | 16 位数据报总长度，60 字节 |
| 0xca49 |  | 16 位数据报标识 |
| 0x4 |  | 3 位标志，设置禁止分片标志 |
| 0x000 | 0 | 13 位分片偏移 |
| 0x40 | 64 | 8 位 TTL，TTL被设为 64 |
| 0x06 | 6 | 8 位协议，协议设为 6，表示上层为 TCP 协议 |
| 0x7260 |  | 16 位 IP 头部校验和 |
| 0x7f000001 |  | 32 位源端 IP 地址 127.0.0.1 |
| 0x7f000001 |  | 32 位目的端 IP 地址 127.0.0.1 |


## 五、IP 分片

### 1. 为什么要分片？

互联网协议使网络互相通信。设计要迎合不同物理性质的网络; 它是独立于链路层使用的基础传输技术。具有不同硬件的网络通常会发生变化，不仅在传输速度，而且在最大传输单元 MTU。当一个网络要把数据报发送到具有较小 MTU 的一个网络，它就有可能数据报进行分片。

在IPv4中，这个功能被放置在网络层。分片可能发生在发送端，也可能发生在中转路由器上，而且可能在传输过程中被多次分片，但只有在最终的目标机器上，这些分片才会被内核中的IP模块重新组装

与此相反，IPv6的下一代互联网协议在发送数据包之前，要求主机必须确定路径MTU。不需要由路由器来执行分片

### 2. 如何实现分片和重组？

IP 分片和重组与 IP 头部中三个字段中的信息有关：**数据报标识、分片标志、片偏移**

一个 IP 数据报的每个分片都具有自己的 IP 头部，它们具有相同的标识值，但具有不同的片偏移。并且除了最后一个分片外，其他分片都将设置 MF 标志。此外，每个分片的 IP 头部的总长度字段将被设置为该分片的长度

以太网帧的 MTU 是 1500 字节（通过 `ifconfig` 或 `netstat` 命令查看），因此它携带的 IP 数据报的数据部分最多是 1480 字节（IP 头部占用 20 字节）。如果用 IP 数据报封装一个长度为 1481 字节的 ICMP 报文（ICMP 头部占用 8 字节，所以其数据部分长度为 1473 字节），则该数据报在使用以太网帧传输时必须被分片，如下图所示：

<div align="center"><image src="../doc/携带ICMP报文的IP数据报被分片.png"></image></div>

上图中，长度为 1501 字节的 IP 数据报被拆分为两个 IP 分片

- 第一个 IP 分片长度为 1500 字节，第二个 IP 分片长度为 21 字节，1473 字节的 ICMP 报文数据的前 1472 字节被 IP 模块复制到第一个 IP 分片中，使其总长度为 1500 字节，从而满足 MTU 的要求，而多出的最后 1 字节则被复制到第二个 IP 分片中
- 每个分片都包含自己的 IP 头部（20 字节）
- 第一个 IP 分片的 IP 头部设置了 MF 标志，第二个 IP 分片的 IP 头部没有设置该标志，因为它已经是最后一个分片了
- 原始 IP 数据报中的 ICMP 头部内容被完整地复制到了第一个 IP 分片中，第二个 IP 分片不包含 ICMP 头部信息，因为 IP 模块重组该 ICMP 报文的时候只需要一份 ICMP 头部信息，重复传送这个信息没有任何用处


### 3. 使用 tcpdump 观察 IP 分片

假设有两台本地机器互连 `PC1(192.168.0.103)` 和 `PC2(192.168.0.105)`，为了看清楚 IP 分片的具体过程，我们从 PC1 来 `ping` PC2，每次传送 1473 字节的数据（ICMP 报文的数据部分）以强制引起 IP 分片，并用 `tcpdump` 抓取此过程中双方交换的数据包

在 PC1 上进行以下操作：

使用 `tcpdump` 抓取 ICMP 报文：

```
sudo tcpdump -ntv -i wlp8s0 icmp
```

然后 `ping` PC2，并且指定每次传送 1473 字节的数据：

```
ping 192.168.0.105 -s 1473
```

查看 tcpdump 输出的一个 IP 数据报的两个分片，内容如下：

```
IP (tos 0x0, ttl 64, id 23389, offset 0, flags [+], proto ICMP (1), length 1500)   
    192.168.0.103 > 192.168.0.105: ICMP echo request, id 4, seq 1, length 1480      
IP (tos 0x0, ttl 64, id 23389, offset 1480, flags [none], proto ICMP (1), length 21)
    192.168.0.103 > 192.168.0.105: ip-proto-1 
```

- 两个 IP 分片的标识值都是 23389，说明它们是同一个 IP 数据报的分片
- 第一个分片偏移值为 0，而第二个则是 1480，第二个分片的偏移值实际上是第一个分片的 ICMP 报文的长度
- 第一个分片设置了 MF 标志以表示还有后续分片，所以 tcpdump 输出 "flags [+]"，而第二个分片则没有设置任何标志，所以 tcpdump 输出 "flags [none]"
- 这两个分片的长度分别为 1500 字节和 21 字节，与分析一致

## 六、IP 路由

IP 协议的核心任务是 **数据报的路由，即决定发送数据到目标机器的路径**

### 1. IP 模块工作流程

IP 模块的基本工作流程如下图所示：

<div align="center"><image src="../doc/IP模块基本工作流程.png"></image></div>

从右往左分析上图：

- 首先，当 IP 模块接收到来自数据链路层的 IP 数据报时，它首先对该数据报的头部做 CRC 校验，确认无误之后就分析其头部的具体信息，否则将其丢弃
- 对头部进行分析：
  - 如果该 IP 数据报的头部设置了 **源站选路选项**（松散或严格源路由选择），则 IP 模块调用 **数据报转发子模块** 来处理该数据报
  - 如果该 IP 数据报的 **目标 IP 地址时本地的 IP 地址或者广播地址**，即该数据报是发送给本机的，则 IP 模块 **根据数据报头部中的协议字段将其交给上层应用**
  - 如果 IP 模块发现这个数据报 **不是发送给本机的**，则 **调用数据报转发子模块处理** 该数据报
- 数据转发子模块将首先检测 **系统是否允许转发**
  - 如果不允许，则将数据报丢弃；
  - 如果允许，则转发子模块对该数据执行一些操作，然后将它交给 IP 数据报输出子模块
- 图中“计算下一跳路由”子模块是根据 **路由表** 判断 IP 数据报应该发送至哪个下一跳路由（或目标机器），以及经过哪个网卡来发送，这就是路由过程
  
  路由表是数据报路由的核心数据结构，其按照数据报的目标 IP 地址分类，同一类型的 IP 数据报将被发往相同的下一跳路由器（或目标机器）
- IP 输出队列中存放的是所有等待发送的 IP 数据报，包括需要转发的 IP 数据报和封装了本机上层数据（ICMP 报文、TCP 报文、UDP 数据报）的 IP 数据报

上图左上角的虚线箭头表示了路由表更新的方式，主要是 **通过路由协议或者 route 命令调整路由表，使之更适应最新的网络拓扑结构，称为 IP 路由策略**

### 2. 路由机制

Linux 上通过 `route` 或 `netstat` 命令查看路由表，以 `route` 的输出为例：

```
Kernel IP routing table                                                       
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface 
default         _gateway        0.0.0.0         UG    600    0        0 wlp8s0
192.168.0.0     0.0.0.0         255.255.255.0   U     600    0        0 wlp8s0
```

该路由表包含两项，每项包含 8 个字段，主要字段的含义如下：

- **Gateway**：网关地址，也即是下一跳的地址，`*` 表示目标和本机在同一网络，不需要路由
- **Genmask**：网络掩码
- **Flags**：
  路由标志，常见标志有如下几种：
  - U：该路由项是活动的
  - H：该路由项的目标是一台主机
  - G：该路由项的目标是网关
  - D：该路由项是由重定向生成的
  - M：该路由项被重定向修改过
- **Metric**：路由距离，即到达指定网络所需的中转数
- **Use**：该路由项被使用的次数
- **lfate**：该路由项输出的网卡接口

上面路由表中，第一项的目标地址是 default，即默认路由项，其 flags 中包含 `G` 标志，说明其下一跳是网关

IP 的路由机制，分为 3 个步骤：

- 查找路由表中和数据报目标 IP 完全匹配的主机 IP，如果找到，就使用该路由项，否则进行第二步查找
- 查找路由表中和数据报目标 IP 具有相同网络 ID 的 网络 IP 地址，如果找到，就使用该路由项，否则进行第三步查找
- 选择默认路由项，这通常意味着数据报的下一跳路由是网关

### 3. 使用 route 修改路由表

可以使用 `route` 修改路由表信息：

```
//添加新路由项，所有发送给 192.168.1.109 的 IP 数据报将通过网卡 wlp8s0 直接发送
route add -host 192.168.1.109 dev wlp8s0
//删除路由项
route del -net 192.168.0.0 netmask 255.255.255.0
//删除默认路由项，无法连接到外部网络
route del default
//添加新默认路由项
route add default gw 192.168.0.1 dev wlp8s0
```

通过 `route` 等工具手动修改路由表是静态的路由更新方式，对于大型路由器，通常通过 BGP、RIP、OSPF等协议发现路径，更新路由表。

[ICMP](ICMP协议.md) 重定向报文也可以更新路由表

### 4. IP 转发

一般来说，IP 转发主要由路由器完成，但是，主机在开启路由转发功能时也可以进行 IP 转发

通过将内核参数 `/proc/sys/net/ipv4/ip_forward` 设为 `1` 来开启 IP 转发功能：

```
echo 1 > /proc/sys/net/ipv4/ip_forward
```

对允许 IP 转发的主机或路由器来说，其转发子模块的处理过程如下：

- 检查数据报头部的 `TTL` 值，如果 TTL 值为 0，则丢弃该数据报
- 查看数据报头部的 `严格源路由选择选项`，如果该选项被设置，则检测数据报的目标 IP 地址是否为本机的某个 IP 地址，如果不是，则发送一个 ICMP 源站选路失败报文给发送端
- 如果有必要，给源端发送一个 ICMP 重定向报文，告诉它一个更合理的下一跳路由器
- 将 TTL 值减 1
- 处理 IP 头部选项
- 如果有必要，执行 IP 分片操作