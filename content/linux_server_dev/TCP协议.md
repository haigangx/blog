# TCP协议

<!-- TOC -->

- [一、TCP 协议的主要内容](#一tcp-协议的主要内容)
- [二、TCP 服务特点](#二tcp-服务特点)
    - [1. 面向连接](#1-面向连接)
    - [2. 字节流](#2-字节流)
    - [3. 可靠传输](#3-可靠传输)
- [三、TCP 头部结构](#三tcp-头部结构)
    - [1. 固定头部](#1-固定头部)
    - [2. 头部选项字段](#2-头部选项字段)
    - [3. 使用 tcpdump 观察 TCP 头部信息](#3-使用-tcpdump-观察-tcp-头部信息)
- [四、TCP 连接的建立和关闭——三次握手四次挥手](#四tcp-连接的建立和关闭三次握手四次挥手)
    - [1. 利用 tcpdump 观察 TCP 连接的建立和关闭](#1-利用-tcpdump-观察-tcp-连接的建立和关闭)
    - [2. 半关闭状态](#2-半关闭状态)
    - [3. 连接超时](#3-连接超时)

<!-- /TOC -->

## 一、TCP 协议的主要内容

TCP 协议是 TCP/IP 协议的一个重要的协议，TCP 协议属于传输层协议，更加靠近应用层。 TCP 协议主要从以下四个方面讨论：

- `TCP 头部信息`

  TCP 头部信息出现在每个 TCP 报文段中，用于指定通信的源端口号、目的端口号、管理 TCP 连接、控制两个方向的数据流

- `TCP 状态转移过程`

  TCP 连接的任意一端都是一个状态机。在 TCP 连接从建立到断开的整个过程中，连接两端的状态机经历不过的状态变迁

- `TCP 数据流`

  讨论两种类型的 TCP 数据流：交互数据流和成块数据流。还有各种特殊的紧急数据

- `TCP 数据流的控制`

  为了保证可靠传输和提高网络通信质量，内核需要对 TCP 数据流进行两种控制：超时重传和拥塞控制

## 二、TCP 服务特点

传输层协议主要有两个：TCP 协议和 UDP 协议。TCP 协议相对于 UDP 协议的特点是：**面向连接、字节流、可靠传输**

### 1. 面向连接

使用 TCP 协议通信的双方必须 **先建立连接**，然后才能开始数据的读写，双方都必须为该连接分配必要的内核资源，以管理连接的状态和连接上数据的传输。TCP 连接是全双工的，即双方的数据读写可以通过一个连接进行。完成数据交换之后，通信双方都必须断开连接以释放系统资源

TCP 协议的连接是 **一对一** 的，所以 **基于广播和多播（目标是多个主机地址）的应用不能使用 TCP 服务**，而无连接协议 UDP 非常适合广播和多播

### 2. 字节流

TCP 数据传送是基于数据流服务的，而 UDP 基于数据报服务。

数据流服务和数据报服务的区别在实际编程中表现为通信双方是否必须执行相同次数的读、写操作

- TCP 读写数据

  当发送端应用程序连续多次写操作时，TCP 模块先将这些数据放入 TCP 发送缓冲区中，当 TCP 模块真正开始发送数据时，发送缓冲区中等待发送的数据会被封装成一个或多个 TCP 报文发出。因此 **TCP 模块发送出的 TCP 报文个数和应用程序执行的写操作之间没有固定的数量关系**

  当接收端收到一个或多个 TCP 报文后，TCP 模块先将其携带的应用程序数据按照报文序号依次放入 TCP 接受缓冲区中，并通知应用程序读取数据。接收端应用程序可以一次性将 TCP 接受缓冲区中的数据全部读出，也可以分多次读取，这取决于用户指定的应用程序读缓冲区的大小。因此 **应用程序执行的读操作和 TCP 模块接收到的 TCP 报文个数之间也没有固定的数量关系**

  综上，发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系，这就是字节流的概念

- UDP 读写数据

  UDP 则不然，发送端应用程序每执行一次写操作，UDP 模块就将其封装成一个 UDP 数据报并发送之。接收端必须及时针对每个 UDP 数据报执行读操作，否则就会丢包，并且，如果用户没有指定足够的应用程序缓冲区来读取 UDP 数据，则 UDP 数据将被截断

<div align="center"><image src="../doc/TCP字节流服务和UDP数据报服务区别.png"></image></div>

### 3. 可靠传输

TCP 传输通过 **发送应答、超时重传、重排整理** 等机制保证可靠性

- 发送应答

  发送端发送的每个 TCP 报文段必须得到接收方的应答，才认为这个 TCP 报文段传输成功

- 超时重传

  发送端在发送出一个 TCP 报文段后启动定时器，如果在定时时间内未收到应答，它将重发该报文段

- 重排整理

  因为 TCP 报文段最终是以 IP 数据报发送的，而 IP 数据报到达接收端可能会乱序、重复，所以 TCP 协议还会对接收到的 TCP 报文段进行重排、整理，再交付给应用层

## 三、TCP 头部结构

TCP 头部信息主要包括通信源端端口、目的端端口、用于管理 TCP 连接的信息等

### 1. 固定头部

<div align="center"><image src="../doc/TCP头部结构.png"></image></div>

- `16 位端口号`

  - `源端口号`：告知主机该报文段来自哪里
  - `目的端口号`：告知主机该报文段传给哪个上层协议或应用程序

  进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号，所有知名服务端口号都定义在 `/etc/services` 文件中

- `32 位序号`：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号

  假设主机 A 和 主机 B 进行 TCP 通信， A 发送给 B 的第一个 TCP 报文段中，序号值被系统初始化为某个随机值 ISN(Initial Sequence Number，初始序号值)。那么在该传输方向上（从 A 到 B），后续的 TCP 报文段中序号值将被系统设置为 ISN 加上该报文段所携带数据的第一个字节在整个字节流中的偏移

  > 例如，某个 TCP 报文段传送的数据是字节流中的第 1025~2048 字节，那么该报文段的序号值就是 ISN+1025。另外一个传输方向（从 B 到 A）的 TCP 报文段的序号值也具有相同的含义

- `32 位确认号`：用作对另一方发送来的 TCP 报文段的相应，其值被设为收到的 TCP 报文段的序号值加 1

  假设主机 A 和主机 B 进行 TCP 通信，那么 A 发送出的 TCP 报文段不仅携带自己的序号，而且包含对 B 发送来的 TCP 报文段的确认号，反之，B 发送出的 TCP 报文段也同时携带自己的序号和对 A 发送来的报文段的确认号

- `4 位头部长度`：标识该 TCP 头部有多少个 32 bit 字( 4 字节)，因为 4 位最大能表示 15，所以 TCP 头部最长是 60 字节

- `6 位标志位`：

  - `URG`：表示紧急指针是否有效
  - `ACK`：表示确认号是否有效，携带 ACK 标志的 TCP 报文段为确认报文段
  - `PSH`：提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，他们就会一直停留在 TCP 接收缓冲区）
  - `RST`：表示要求对方重新建立连接，携带 RST 标志的为复位报文段
  - `SYN`：表示请求建立一个连接，携带 SYN 标志的为同步报文段
  - `FIN`：表示通知对方本段要关闭连接了，携带 FIN 标志的为结束报文段

- `16 位窗口大小`：是用于 TCP 实现流量控制的

  窗口指接收通告窗口(Receiver Window, RWND)。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度

- `16 位校验和`：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以检验 TCP 报文段在传输过程中是否损坏

  注意：这个校验不仅包括 TCP 头部，也包括数据部分，是 TCP 可靠传输的重要保障

- `16 位紧急指针`：是一个正的偏移量，表示紧急指针相对于当前序号的偏移

  TCP 的紧急指针是发送端向接收端发送紧急数据的方法，它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号


### 2. 头部选项字段

TCP 头部的最后一个选项字段是可变长的可选信息。这部分最多包含 40 字节，因为 TCP 头部最长是 60 字节（包含 20 字节的固定部分）

选项字段结构图如下：

<div align="center"><image src="../doc/TCP头部选项字段结构.png"></image></div>

- `kind`：说明选项的类型。有的 TCP 选项没有后面两个字段，仅包含 1 字节的 kind 字段
- `length`：指定该选项的总长度，包括 kind 字段和 length 字段占据的 2 字节
- `info`：是选项的具体信息

常见的 TCP 选项有 7 种：

<div align="center"><image src="../doc/7种TCP选项.png"></image></div>

- `kind = 0`：选项表结束选项
- `kind = 1`：空操作选项，没有特殊含义，一般用于将 TCP 选项的总长度填充为 4 字节的整数倍
- `kind = 2`：最大报文段长度选项，通信双方使用该选项来协商最大报文段长度(Max Segment Size, MSS)
  TCP 模块通常将 MSS 设置为 MTU-40 字节（减掉的 40 字节包括 20 字节的 TCP 头部和 20 字节的 IP 头部）。这样是为了尽可能避免本机发生 IP 分片，对以太网而言，MSS 值是 1460(1500-40) 字节
- `kind = 3`：窗口扩大因子选项，TCP 连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子
  在 TCP 头部中，接收通告窗口大小是用 16 位表示的，故最大为 65535 字节，但实际上 TCP 模块允许的接收通告窗口大小远不止这个数（为了提高 TCP 通信的吞吐量）。窗口扩大因子解决了这个问题。

  假设 TCP 头部中的接收通告窗口大小是 N，窗口扩大因子是 M，那么 TCP 报文段的实际接收通告窗口大小为 N*2<sup>M</sup>，或者说 N 左移 M 位，M 的取值范围为 0~14
  
  可以通过修改 `/proc/sys/net/ipv4/tcp_window_scaling` 内核变量来启用或关闭窗口扩大因子选项

  窗口扩大因子选项和 MSS 选项都只能出现在同步报文段中，否则将被忽略。同步报文本身不执行窗口扩大的操作，即同步报文段头部的接收通告窗口大小就是该 TCP 报文段的实际接收通告窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了

- `kind = 4`：选择性确认选项（Selective Acknowledement, SACK）

  TCP 通信时，如果某个 TCP 报文段丢失，则 TCP 模块会重传最后被确认的 TCP 报文段后续的所有报文段，这样原先已经正确传输的 TCP 报文段也可能重复发送，从而降低了 TCP 性能

  SACK 技术改善这种情况，使 TCP 模块只重新发送丢失的 TCP 报文段，不用发送所有未被确认的 TCP 报文段。选择性确认选项在连接初始化时，表示是否支持 SACK 技术

  可以通过修改 `/proc/sys/net/ipv4/tcp_sack` 内核变量来启用或关闭选择性确认选项

- `kind = 5`：是 SACK 实际工作的选项，该选项的参数告诉发送方本段已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块

  每个块边沿(edge of block)参数包含一个 4 字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿表示不连续块的最后一个数据的序号的下一个序号，这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用 8 字节，所以 TCP 头部选项中实际最多可以包含 4 个这样的不连续数据块（类型和长度占用 2 字节）

- `kind = 8`：时间戳选项，该选项提供了较为准确的计算通信双方之间的回路时间（Round Trip Time，RTT）的方法，为 TCP 流量控制提供了重要信息

  可以通过修改 `/proc/sys/net/ipv4/tcp_timestamps` 内核变量来启用或关闭时间戳选项

### 3. 使用 tcpdump 观察 TCP 头部信息

我们利用分析 [IP协议](IP协议.md) 时抓取的 TCP 数据包对 TCP 协议相关部分进行分析：

```
IP 127.0.0.1.38560 > 127.0.0.1.23: Flags [S], seq 4242890062, win 65495, options [mss 65495,sackOK,TS val 3913303147 ecr 0,nop,wscale 7], length 0                                                                
        0x0000:  4510 003c ca49 4000 4006 7260 7f00 0001                                                 
        0x0010:  7f00 0001 96a0 0017 fce5 5d4e 0000 0000                                                 
        0x0020:  a002 ffd7 fe30 0000 0204 ffd7 0402 080a                                                 
        0x0030:  e940 446b 0000 0000 0103 0307
```

- `Flags [S]` ：表示该 TCP 报文段包含 SYN 标志，是一个同步报文段，如果 TCP 报文段包含其他标志，则 tcpdump 会将标志首字母显示在 Flags 后的方括号中
- `seq 4242890062`：序号值，因为该同步报文段是通信双方发送的第一个 TCP 报文段，所以这个序号值就是此次通信过程中该传输方向的 ISN 值，而且，由于是第一个 TCP 报文段，所以它没有针对对方发送来的 TCP 报文段的确认值（表示尚未收到任何对方来的 TCP 报文段）
- `win 65495`：表示接收通告窗口的大小，因为这是一个同步报文段，所以 win 值反映的是实际的接收通告窗口大小
- `options [...]`：是 TCP 选项，其具体内容在 `"[]"` 内
  - `mss 65495`：发送端通告的最大报文段长度
  - `sackOK`：表示发送端支持并同意使用 SACK 选项
  - `TS val 3913303147`：发送端的时间戳
  - `ecr 0`：时间戳回显应答，因为是一次 TCP 通信的第一个 TCP 报文段，所以它针对对方的时间戳的应答为 0（表示尚未收到对方的时间戳）
  - `nop`：表示空操作选项
  - `wscale 7`：指出发送端使用的窗口扩大因子为 7

接下来分析 tcpdump 输出的字节码中 TCP 头部对应的信息，从第 21 个字节开始，前 20 字节为 IP 头部：

| 十六进制数 | 十进制表示 | TCP 头部信息 |
| --- | --- | --- |
| 0x96a0 | 38560 | 16 位源端口号 |
| 0x0017 | 23 | 16 位目的端口号 |
| 0xfce55d4e | ‭4242890062‬ | 32 位序号 |
| 0x00000000 | 0 | 32 位确认号 |
| 0xa | 10 | 4 位头部长度，长度为 10 个 32 位（40 字节） | 
| 0x002 |  |  设置了 SYN 标志 |
| 0xffd7 | ‭65495‬ | 16 位接收通告窗口大小 |
| 0xfe30 |  | 16 位校验和 |
| 0x0000 |  | 16 位紧急指针，没设置 URG 标志，紧急指针无意义 |
| 0x0204 |  | 最大报文段长度选项的 kind 值和 length 值 |
| 0xffd7 | ‭65495‬ | 最大报文段长度 |
| 0x0402 |  | 允许 SACK 选项 |
| 0x080a |  | 时间戳选项的 kind 值和 length 值 |
| 0xe940446b | ‭3913303147‬ | 时间戳 |
| 0x00000000 | 0 | 回显应答时间戳 |
| 0x01 |  | 空操作选项 |
| 0x0303 |  | 窗口扩大因子选项的 kind 值和 length 值 |
| 0x07 | 7 | 窗口扩大因子为 7 |

从上表可以看出，TCP 报文段头部的二进制码和 tcpdump 输出的 TCP 报文段描述信息完全对应

## 四、TCP 连接的建立和关闭——三次握手四次挥手

### 1. 利用 tcpdump 观察 TCP 连接的建立和关闭

### 2. 半关闭状态

### 3. 连接超时