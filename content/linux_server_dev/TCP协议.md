# TCP协议

<!-- TOC -->

- [一、TCP 协议的主要内容](#一tcp-协议的主要内容)
- [二、TCP 服务特点](#二tcp-服务特点)
    - [1. 面向连接](#1-面向连接)
    - [2. 字节流](#2-字节流)
    - [3. 可靠传输](#3-可靠传输)
- [三、TCP 头部结构](#三tcp-头部结构)
    - [1. 固定头部](#1-固定头部)
    - [2. 头部选项字段](#2-头部选项字段)
    - [3. 使用 tcpdump 观察 TCP 头部信息](#3-使用-tcpdump-观察-tcp-头部信息)
- [四、TCP 连接的建立和关闭——三次握手四次挥手](#四tcp-连接的建立和关闭三次握手四次挥手)
    - [1. 利用 tcpdump 观察 TCP 连接的建立和关闭](#1-利用-tcpdump-观察-tcp-连接的建立和关闭)
        - [三次握手过程](#三次握手过程)
        - [四次挥手过程](#四次挥手过程)
    - [2. 半关闭状态](#2-半关闭状态)
    - [3. 连接超时](#3-连接超时)
- [五、TCP 状态转移](#五tcp-状态转移)
    - [1. TCP 状态转移总图](#1-tcp-状态转移总图)
    - [2. TIME_WAIT 状态](#2-time_wait-状态)
        - [为什么要有需要等待 2MSL 时间的 TIME_WAIT 状态？](#为什么要有需要等待-2msl-时间的-time_wait-状态)
        - [强制占用 TIME_WAIT 状态的连接的端口](#强制占用-time_wait-状态的连接的端口)
- [六、复位报文段](#六复位报文段)
- [七、TCP 交互数据流和成块数据流](#七tcp-交互数据流和成块数据流)
    - [1. TCP 交互数据流](#1-tcp-交互数据流)
        - [延迟确认](#延迟确认)
        - [Nagle 算法](#nagle-算法)
    - [2. TCP 成块数据流](#2-tcp-成块数据流)
- [八、带外数据](#八带外数据)
    - [1. 什么是带外数据](#1-什么是带外数据)
    - [2. TCP 中如何发送带外数据](#2-tcp-中如何发送带外数据)
        - [TCP发送带外数据的过程](#tcp发送带外数据的过程)
        - [TCP 接收带外数据的过程](#tcp-接收带外数据的过程)
- [九、TCP 超时重传](#九tcp-超时重传)
    - [1. 超时重传机制](#1-超时重传机制)
    - [2. 使用 tcpdump 观察超时重传机制](#2-使用-tcpdump-观察超时重传机制)
- [十、TCP 拥塞控制](#十tcp-拥塞控制)
    - [1. 拥塞控制概述](#1-拥塞控制概述)
    - [2. 拥塞控制状态转移](#2-拥塞控制状态转移)
    - [3. 拥塞控制四大部分：慢启动、拥塞避免、拥塞发生、快速恢复](#3-拥塞控制四大部分慢启动拥塞避免拥塞发生快速恢复)
        - [慢启动](#慢启动)
        - [拥塞避免](#拥塞避免)
        - [拥塞发生](#拥塞发生)
        - [快速恢复](#快速恢复)
- [十一、TCP 问题](#十一tcp-问题)
    - [未完待续](#未完待续)

<!-- /TOC -->

## 一、TCP 协议的主要内容

TCP 协议是 TCP/IP 协议的一个重要的协议，TCP 协议属于传输层协议，更加靠近应用层。 TCP 协议主要从以下四个方面讨论：

- `TCP 头部信息`

  TCP 头部信息出现在每个 TCP 报文段中，用于指定通信的源端口号、目的端口号、管理 TCP 连接、控制两个方向的数据流

- `TCP 状态转移过程`

  TCP 连接的任意一端都是一个状态机。在 TCP 连接从建立到断开的整个过程中，连接两端的状态机经历不过的状态变迁

- `TCP 数据流`

  讨论两种类型的 TCP 数据流：交互数据流和成块数据流。还有各种特殊的紧急数据

- `TCP 数据流的控制`

  为了保证可靠传输和提高网络通信质量，内核需要对 TCP 数据流进行两种控制：超时重传和拥塞控制

## 二、TCP 服务特点

传输层协议主要有两个：TCP 协议和 UDP 协议。TCP 协议相对于 UDP 协议的特点是：**面向连接、字节流、可靠传输**

### 1. 面向连接

使用 TCP 协议通信的双方必须 **先建立连接**，然后才能开始数据的读写，双方都必须为该连接分配必要的内核资源，以管理连接的状态和连接上数据的传输。TCP 连接是全双工的，即双方的数据读写可以通过一个连接进行。完成数据交换之后，通信双方都必须断开连接以释放系统资源

TCP 协议的连接是 **一对一** 的，所以 **基于广播和多播（目标是多个主机地址）的应用不能使用 TCP 服务**，而无连接协议 UDP 非常适合广播和多播

### 2. 字节流

TCP 数据传送是基于数据流服务的，而 UDP 基于数据报服务。

数据流服务和数据报服务的区别在实际编程中表现为通信双方是否必须执行相同次数的读、写操作

- TCP 读写数据

  当发送端应用程序连续多次写操作时，TCP 模块先将这些数据放入 TCP 发送缓冲区中，当 TCP 模块真正开始发送数据时，发送缓冲区中等待发送的数据会被封装成一个或多个 TCP 报文发出。因此 **TCP 模块发送出的 TCP 报文个数和应用程序执行的写操作之间没有固定的数量关系**

  当接收端收到一个或多个 TCP 报文后，TCP 模块先将其携带的应用程序数据按照报文序号依次放入 TCP 接受缓冲区中，并通知应用程序读取数据。接收端应用程序可以一次性将 TCP 接受缓冲区中的数据全部读出，也可以分多次读取，这取决于用户指定的应用程序读缓冲区的大小。因此 **应用程序执行的读操作和 TCP 模块接收到的 TCP 报文个数之间也没有固定的数量关系**

  综上，发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系，这就是字节流的概念

- UDP 读写数据

  UDP 则不然，发送端应用程序每执行一次写操作，UDP 模块就将其封装成一个 UDP 数据报并发送之。接收端必须及时针对每个 UDP 数据报执行读操作，否则就会丢包，并且，如果用户没有指定足够的应用程序缓冲区来读取 UDP 数据，则 UDP 数据将被截断

<div align="center"><image src="../doc/TCP字节流服务和UDP数据报服务区别.png"></image></div>

### 3. 可靠传输

TCP 传输通过 **发送应答、超时重传、重排整理** 等机制保证可靠性

- 发送应答

  发送端发送的每个 TCP 报文段必须得到接收方的应答，才认为这个 TCP 报文段传输成功

- 超时重传

  发送端在发送出一个 TCP 报文段后启动定时器，如果在定时时间内未收到应答，它将重发该报文段

- 重排整理

  因为 TCP 报文段最终是以 IP 数据报发送的，而 IP 数据报到达接收端可能会乱序、重复，所以 TCP 协议还会对接收到的 TCP 报文段进行重排、整理，再交付给应用层

## 三、TCP 头部结构

TCP 头部信息主要包括通信源端端口、目的端端口、用于管理 TCP 连接的信息等

### 1. 固定头部

<div align="center"><image src="../doc/TCP头部结构.png"></image></div>

- `16 位端口号`

  - `源端口号`：告知主机该报文段来自哪里
  - `目的端口号`：告知主机该报文段传给哪个上层协议或应用程序

  进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号，所有知名服务端口号都定义在 `/etc/services` 文件中

- `32 位序号`：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号

  假设主机 A 和 主机 B 进行 TCP 通信， A 发送给 B 的第一个 TCP 报文段中，序号值被系统初始化为某个随机值 ISN(Initial Sequence Number，初始序号值)。那么在该传输方向上（从 A 到 B），后续的 TCP 报文段中序号值将被系统设置为 ISN 加上该报文段所携带数据的第一个字节在整个字节流中的偏移

  > 例如，某个 TCP 报文段传送的数据是字节流中的第 1025~2048 字节，那么该报文段的序号值就是 ISN+1025。另外一个传输方向（从 B 到 A）的 TCP 报文段的序号值也具有相同的含义

- `32 位确认号`：用作对另一方发送来的 TCP 报文段的相应，其值被设为收到的 TCP 报文段的序号值加 1

  假设主机 A 和主机 B 进行 TCP 通信，那么 A 发送出的 TCP 报文段不仅携带自己的序号，而且包含对 B 发送来的 TCP 报文段的确认号，反之，B 发送出的 TCP 报文段也同时携带自己的序号和对 A 发送来的报文段的确认号

- `4 位头部长度`：标识该 TCP 头部有多少个 32 bit 字( 4 字节)，因为 4 位最大能表示 15，所以 TCP 头部最长是 60 字节

- `6 位标志位`：

  - `URG`：表示紧急指针是否有效
  - `ACK`：表示确认号是否有效，携带 ACK 标志的 TCP 报文段为确认报文段
  - `PSH`：提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，他们就会一直停留在 TCP 接收缓冲区）
  - `RST`：表示要求对方重新建立连接，携带 RST 标志的为复位报文段
  - `SYN`：表示请求建立一个连接，携带 SYN 标志的为同步报文段
  - `FIN`：表示通知对方本段要关闭连接了，携带 FIN 标志的为结束报文段

- `16 位窗口大小`：是用于 TCP 实现流量控制的

  窗口指接收通告窗口(Receiver Window, RWND)。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度

- `16 位校验和`：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以检验 TCP 报文段在传输过程中是否损坏

  注意：这个校验不仅包括 TCP 头部，也包括数据部分，是 TCP 可靠传输的重要保障

- `16 位紧急指针`：是一个正的偏移量，表示紧急指针相对于当前序号的偏移

  TCP 的紧急指针是发送端向接收端发送紧急数据的方法，它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号


### 2. 头部选项字段

TCP 头部的最后一个选项字段是可变长的可选信息。这部分最多包含 40 字节，因为 TCP 头部最长是 60 字节（包含 20 字节的固定部分）

选项字段结构图如下：

<div align="center"><image src="../doc/TCP头部选项字段结构.png"></image></div>

- `kind`：说明选项的类型。有的 TCP 选项没有后面两个字段，仅包含 1 字节的 kind 字段
- `length`：指定该选项的总长度，包括 kind 字段和 length 字段占据的 2 字节
- `info`：是选项的具体信息

常见的 TCP 选项有 7 种：

<div align="center"><image src="../doc/7种TCP选项.png"></image></div>

- `kind = 0`：选项表结束选项
- `kind = 1`：空操作选项，没有特殊含义，一般用于将 TCP 选项的总长度填充为 4 字节的整数倍
- `kind = 2`：最大报文段长度选项，通信双方使用该选项来协商最大报文段长度(Max Segment Size, MSS)
  TCP 模块通常将 MSS 设置为 MTU-40 字节（减掉的 40 字节包括 20 字节的 TCP 头部和 20 字节的 IP 头部）。这样是为了尽可能避免本机发生 IP 分片，对以太网而言，MSS 值是 1460(1500-40) 字节
- `kind = 3`：窗口扩大因子选项，TCP 连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子
  在 TCP 头部中，接收通告窗口大小是用 16 位表示的，故最大为 65535 字节，但实际上 TCP 模块允许的接收通告窗口大小远不止这个数（为了提高 TCP 通信的吞吐量）。窗口扩大因子解决了这个问题。

  假设 TCP 头部中的接收通告窗口大小是 N，窗口扩大因子是 M，那么 TCP 报文段的实际接收通告窗口大小为 N*2<sup>M</sup>，或者说 N 左移 M 位，M 的取值范围为 0~14
  
  可以通过修改 `/proc/sys/net/ipv4/tcp_window_scaling` 内核变量来启用或关闭窗口扩大因子选项

  窗口扩大因子选项和 MSS 选项都只能出现在同步报文段中，否则将被忽略。同步报文本身不执行窗口扩大的操作，即同步报文段头部的接收通告窗口大小就是该 TCP 报文段的实际接收通告窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了

- `kind = 4`：选择性确认选项（Selective Acknowledement, SACK）

  TCP 通信时，如果某个 TCP 报文段丢失，则 TCP 模块会重传最后被确认的 TCP 报文段后续的所有报文段，这样原先已经正确传输的 TCP 报文段也可能重复发送，从而降低了 TCP 性能

  SACK 技术改善这种情况，使 TCP 模块只重新发送丢失的 TCP 报文段，不用发送所有未被确认的 TCP 报文段。选择性确认选项在连接初始化时，表示是否支持 SACK 技术

  可以通过修改 `/proc/sys/net/ipv4/tcp_sack` 内核变量来启用或关闭选择性确认选项

- `kind = 5`：是 SACK 实际工作的选项，该选项的参数告诉发送方本段已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块

  每个块边沿(edge of block)参数包含一个 4 字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿表示不连续块的最后一个数据的序号的下一个序号，这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用 8 字节，所以 TCP 头部选项中实际最多可以包含 4 个这样的不连续数据块（类型和长度占用 2 字节）

- `kind = 8`：时间戳选项，该选项提供了较为准确的计算通信双方之间的回路时间（Round Trip Time，RTT）的方法，为 TCP 流量控制提供了重要信息

  可以通过修改 `/proc/sys/net/ipv4/tcp_timestamps` 内核变量来启用或关闭时间戳选项

### 3. 使用 tcpdump 观察 TCP 头部信息

我们利用分析 [IP协议](IP协议.md) 时抓取的 TCP 数据包对 TCP 协议相关部分进行分析：

```
IP 127.0.0.1.38560 > 127.0.0.1.23: Flags [S], seq 4242890062, win 65495, options [mss 65495,sackOK,TS val 3913303147 ecr 0,nop,wscale 7], length 0                                                                
        0x0000:  4510 003c ca49 4000 4006 7260 7f00 0001                                                 
        0x0010:  7f00 0001 96a0 0017 fce5 5d4e 0000 0000                                                 
        0x0020:  a002 ffd7 fe30 0000 0204 ffd7 0402 080a                                                 
        0x0030:  e940 446b 0000 0000 0103 0307
```

- `Flags [S]` ：表示该 TCP 报文段包含 SYN 标志，是一个同步报文段，如果 TCP 报文段包含其他标志，则 tcpdump 会将标志首字母显示在 Flags 后的方括号中
- `seq 4242890062`：序号值，因为该同步报文段是通信双方发送的第一个 TCP 报文段，所以这个序号值就是此次通信过程中该传输方向的 ISN 值，而且，由于是第一个 TCP 报文段，所以它没有针对对方发送来的 TCP 报文段的确认值（表示尚未收到任何对方来的 TCP 报文段）
- `win 65495`：表示接收通告窗口的大小，因为这是一个同步报文段，所以 win 值反映的是实际的接收通告窗口大小
- `options [...]`：是 TCP 选项，其具体内容在 `"[]"` 内
  - `mss 65495`：发送端通告的最大报文段长度
  - `sackOK`：表示发送端支持并同意使用 SACK 选项
  - `TS val 3913303147`：发送端的时间戳
  - `ecr 0`：时间戳回显应答，因为是一次 TCP 通信的第一个 TCP 报文段，所以它针对对方的时间戳的应答为 0（表示尚未收到对方的时间戳）
  - `nop`：表示空操作选项
  - `wscale 7`：指出发送端使用的窗口扩大因子为 7

接下来分析 tcpdump 输出的字节码中 TCP 头部对应的信息，从第 21 个字节开始，前 20 字节为 IP 头部：

| 十六进制数 | 十进制表示 | TCP 头部信息 |
| --- | --- | --- |
| 0x96a0 | 38560 | 16 位源端口号 |
| 0x0017 | 23 | 16 位目的端口号 |
| 0xfce55d4e | ‭4242890062‬ | 32 位序号 |
| 0x00000000 | 0 | 32 位确认号 |
| 0xa | 10 | 4 位头部长度，长度为 10 个 32 位（40 字节） | 
| 0x002 |  |  设置了 SYN 标志 |
| 0xffd7 | ‭65495‬ | 16 位接收通告窗口大小 |
| 0xfe30 |  | 16 位校验和 |
| 0x0000 |  | 16 位紧急指针，没设置 URG 标志，紧急指针无意义 |
| 0x0204 |  | 最大报文段长度选项的 kind 值和 length 值 |
| 0xffd7 | ‭65495‬ | 最大报文段长度 |
| 0x0402 |  | 允许 SACK 选项 |
| 0x080a |  | 时间戳选项的 kind 值和 length 值 |
| 0xe940446b | ‭3913303147‬ | 时间戳 |
| 0x00000000 | 0 | 回显应答时间戳 |
| 0x01 |  | 空操作选项 |
| 0x0303 |  | 窗口扩大因子选项的 kind 值和 length 值 |
| 0x07 | 7 | 窗口扩大因子为 7 |

从上表可以看出，TCP 报文段头部的二进制码和 tcpdump 输出的 TCP 报文段描述信息完全对应

## 四、TCP 连接的建立和关闭——三次握手四次挥手

### 1. 利用 tcpdump 观察 TCP 连接的建立和关闭

在本机(192.168.1.108)上使用 `telnet` 命令登录 `192.168.1.109` 的 80 端口，然后使用 `tcpdump` 抓取这个过程中客户端和服务器交换的 TCP 报文段

使用 `tcpdump` 抓取数据：

```
sudo tcpdump -i eth0 -nt '(src 192.168.1.109 and dst 192.168.1.108) or (src 192.168.1.108 and dst 192.168.1.109)'
```

在另一个终端上使用 `telnet` 登录 `192.168.1.109` 的 80 端口，连接成功会退出：

```
telnet 192.168.1.109 80
Trying 192.168.1.109...
Connected to 192.168.1.109.
Escape character is '^]'.
^]（回车） # 输入 ctrl + ] 并回车

telnet> quit（回车）
Connection closed.
```

上面 telnet 命令实现了 TCP 连接的建立到关闭的过程，`tcpdump` 的输出如下：

```
1. IP 192.168.1.108.60871 > 192.168.1.109.80: Flags [S], seq 535734930, win 5840, length 0
2. IP 192.168.1.109.80 > 192.168.1.108.60871: Flags [S.], seq 2159701207, ack 535734931, win 5792, length 0
3. IP 192.168.1.108.60871 > 192.168.1.109.80: Flags [.], ack 1, win 92, length 0
4. IP 192.168.1.108.60871 > 192.168.1.109.80: Flags [F.], seq 1, ack 1, win 92, length 0
5. IP 192.168.1.109.80 > 192.168.1.108.80971: Flags [.], ack 2, win 91, length 0
6. IP 192.168.1.109.80 > 192.168.1.108.80971: Flags [F.], seq 1, ack 2, win 91, length 0
7. IP 192.168.1.108.60871 > 192.168.1.109.80: Flags [.], ack 2, win 92, length 0
```

整个过程没有发生应用层数据的交换，所以 TCP 报文段的数据部分的长度（length）总是 0，可以将上面的过程绘制成下面的时序图（开启 tcpdump 的 -S 选项来选择打印序号的绝对值）：

<div align="center"><image src="../doc/TCP连接的建立和关闭时序图.png"></image></div>

#### 三次握手过程

- 报文段 1 包含 SYN 标志，是一个同步报文段，即客户端 108 向 服务器 109 发起连接请求，该同步报文段包含一个 ISN 值为 535734930 的序号
- 报文段 2 也是同步报文段，表示 109 同意与 108 建立连接，同时发送自己的 ISN 值为 2159701207 的序号，并发送确认值 535734931 对第一个同步报文段进行确认，即第一个同步报文段的序号值加 1
  > 前面说过，序号值是用来标识 TCP 数据流中的每一个字节的，但同步报文段比较特殊，即使它没有携带任何应用程序数据，也要占用一个序号值
- 报文段 3 是 108 对 同步报文段 2 的确认

至此，TCP 三次握手完成，连接建立

#### 四次挥手过程

- 报文段 4 包含 FIN 标志，是一个结束报文段，即客户端 108 要求关闭连接，结束报文段和同步报文段一样，也要占用一个序号值
- 报文段 5 用来确认结束报文段 4
- 报文段 6 是服务器端发送给客户端的结束报文段
- 报文段 7 用来确认结束报文段 6

实际上，仅用于确认目的的确认报文段 5 是可以省略的，因为结束报文段 6 也携带了该确认信息，确认报文段 5 是否出现在连接断开的过程中，取决于 TCP 的延迟确认特性

上面的挥手过程中，客户端先发送结束报文段给服务器端，因此称客户端执行主动关闭，服务器执行被动关闭

### 2. 半关闭状态

TCP 连接是全双工的，所以它允许两个方向的数据传输被独立关闭

通信的一端主动关闭时，不能再发送数据给对端，但还可以继续接收来自对端的数据，直到对端也关闭连接另一端，TCP 连接的这种状态称为 **半关闭状态（half close）**，如下图：

<div align="center"><image src="../doc/TCP连接的半关闭状态.png"></image></div>

- 可以通过 read 系统调用返回 0 判断对方已经关闭连接
- socket API 中 通过 shutdown 函数 提供了对半关闭的支持

### 3. 连接超时

客户端连接服务器时，如果因为网络问题，服务器无法对连接做出应答时，客户端程序会怎么做？

一般，对于提供可靠服务的 TCP 来说，会先进行多次重连，如果重连仍然无效，则通知应用程序连接失败

下面，我们模拟一个繁忙的服务器环境，然后用客户端连接服务器：

先在服务器 109 上利用 `iptable` 命令过滤掉数据包，使其丢弃所有接收到的连接请求：

```
sudo iptables -F
sudo iptables -I INPUT -p tcp --syn -i eth0 -j DROP
```

下来，从客户端 108 执行 `telnet` 命令登录到服务器，并利用 `tcpdump` 抓取这个过程中的 TCP 报文段：

```
sudo tcpdump -n -i eth0 port 23
date; telnet 192.168.1.109; date  # 在 telnet 命令前后都执行 date 命令，以计算超时时间
Mon Jun 11 21:23:35 CST 2019
Try 192.168.1.109...
telnet: connect to address 192.168.1.109: Connection timed out
Mon Jun 11 21:24:38 CST 2019
```

从两次 `date` 命令看，客户端建立 TCP 连接的超时时间为 63 s

`tcpdump` 的输出如下：

```
1. 21:23:35.612136 IP 192.168.1.109.39385 > 192.168.1.108.telnet: Flags [S], seq 1355982096, length 0
2. 21:23:36.613146 IP 192.168.1.109.39385 > 192.168.1.108.telnet: Flags [S], seq 1355982096, length 0
3. 21:23:38.617279 IP 192.168.1.109.39385 > 192.168.1.108.telnet: Flags [S], seq 1355982096, length 0
4. 21:23:38.625140 IP 192.168.1.109.39385 > 192.168.1.108.telnet: Flags [S], seq 1355982096, length 0
5. 21:23:38.641344 IP 192.168.1.109.39385 > 192.168.1.108.telnet: Flags [S], seq 1355982096, length 0
6. 21:23:38.673331 IP 192.168.1.109.39385 > 192.168.1.108.telnet: Flags [S], seq 1355982096, length 0
```

- tcpdump 不适用 `-t` 选项可以输出时间戳，我们一共抓取到 6 个 TCP 报文段，它们都是同步报文段，并且具有相同的序号值，说明后面 5 个同步报文段都是超时重传报文段
- 这些 TCP 报文段被发送的时间间隔大致为 1s、2s、4s、8s、16s、32s，可见 TCP 模块一共执行了 5 次重连操作，这是由 `/proc/sys/net/ipv4/tcp_syn_retries` 内核变量所定义的，每次重连的超时时间都增加一倍，5 次重连均失败后，TCP 模块放弃连接并通知应用程序

## 五、TCP 状态转移

### 1. TCP 状态转移总图

TCP 连接的任意一端在任一时刻都处于某种状态，当前状态可通过 `netstat` 命令查看

下图是 TCP 连接从建立到关闭的整个过程中通信两端状态的变化，它描绘了所有的 TCP 状态以及可能的状态转换

<div align="center"><image src="../doc/TCP状态转移过程.png"></image></div>

> - 粗虚线表示典型的服务器端连接的状态转移；粗实线表示典型的客户端连接的状态转移
> - CLOSED 是一个假想的起始点，并不是实际的状态

下面对上图从服务端和客户端两个角度进行说明：

- 服务端

  - 服务器通过 `listen` 系统调用进入 `LISTEN` 状态，被动等待客户端连接
  - 当服务器监听到某个连接请求（收到同步报文段），就将该连接放入内核等待队列中，并向客户端发送带 SYN 标志的确认报文段，此时，该连接处于 `SYN_RCVD` 状态
  - 如果服务器成功接收到客户端发送回的确认报文段，则该连接转移到 `ESTABLISHED` 状态，ESTABLISHED 状态就是连接双方能够进行双向数据传输的状态
  - 当客户端主动关闭连接时（通过 `close` 或 `shutdown` 系统调用向服务器发送结束报文段），服务器通过返回确认报文段使连接进入 `CLOSE_WAIT` 状态，这个状态含义很明确，就是等待服务器应用程序关闭连接
  - 服务器检测到客户端关闭连接，也会立即给客户端发送一个结束报文段来关闭连接，这将使连接转移到 `LASK_ACK` 状态，以等待客户端对结束报文段的最后一次确认，一旦确认完成，连接将彻底关闭

- 客户端

  - 客户端通过 `connect` 系统调用主动与服务器建立连接，connect 系统调用给服务器发送一个同步报文段，使连接转移到 `SYN_SENT` 状态
    connect 系统调用可能因为以下两个原因失败返回：
    - 目标端口不存在（未被任何进程监听）或该端口仍被处于 `TIME_WAIT` 状态的连接占用，则服务器将给客户端发送一个复位报文段，connect 调用失败
    - 目标端口存在，但 connect 在超时时间内未收到服务器的确认报文段，connect 调用失败
  - connect 调用失败将使连接立即返回到初始的 `CLOSED` 状态；若客户端收到服务器的同步报文段和确认，则 connect 调用成功返回，连接转移至 `ESTABLISHED` 状态
  - 当客户端执行主动关闭时，会向服务器发送一个结束报文段，同时连接进入 `FIN_WAIT_1` 状态
    - 若此时客户端收到服务器专门用于确认目的地确认报文段，则连接转移至 `FIN_WAIT_2` 状态，当客户端处于 `FIN_WAIT_2` 状态时，服务器处于 `CLOSE_WAIT` 状态，这一对状态是可能发送半关闭的状态。如果此时服务器也关闭连接（发送结束报文段），则客户端将给予确认并进入 `TIME_WAIT` 状态，否则客户端将一直处于 `FIN_WAIT_2` 状态
      > 如果不是为了在半关闭状态下继续接收数据，连接长时间处于 `FIN_WAIT_2` 状态并无益处。连接停留在 `FIN_WAIT_2` 状态的情况可能发生在：客户端执行半关闭后，未等服务器关闭连接就强行退出了。此时客户端连接由内核接管，可称为孤儿连接。
      >
      > Linux 中定义了两个内核变量 `/proc/sys/net/ipv4/tcp_max_orphans` 和 `/proc/sys/net/ipv4/tcp_fin_timeout`，前者指定内核能接管的孤儿连接数目，后者指定孤儿连接在内核中生存的时间
    - 若此时客户端直接收到带确认信息的结束报文段（而不是先收到确认报文段，再收到结束报文段），客户端会从 FIN_WAIT_1 状态直接进入 `TIME_WAIT` 状态（不经过 FIN_WAIT_2）

对应于第四节中利用 tcpdump 观察 TCP 建立和关闭中的时序图，客户端和服务器的状态转移图如下：

<div align="center"><image src="../doc/TCP连接的建立和断开过程中状态转移变化.png"></image></div>

### 2. TIME_WAIT 状态

从上面的状态转移时序图来看，客户端连接在收到服务器的结束报文段 6 之后，并没有直接进入 CLOSED 状态，而是转移到了 `TIME_WAIT` 状态，在这个状态下，客户端连接要等待一段长为 **2MSL(Maximum Segment Life, 报文段最大生存时间)** 的时间，才能完全关闭。

> MSL 是 TCP 报文段在网络中的最大生存时间，标准文档的建议值为 2min

#### 为什么要有需要等待 2MSL 时间的 TIME_WAIT 状态？

TIME_WAIT 状态存在的原因有两点：

- 可靠地终止 TCP 连接

  以上面状态转移图为例，假设用于确认服务器结束报文段 6 的 TCP 报文段 7 丢失，那么服务器将重发结束报文段，因此客户端需要停留在某个状态以处理重复收到的结束报文段（即向服务器发送结束报文段）。否则，客户端将以复位报文段回应服务器，服务器则认为这是一个错误，因为它期望的是一个像 TCP 报文段 7 那样的确认报文段

- 保证让迟来的 TCP 报文段有足够的时间被识别并丢弃

  Linux 系统上，一个 TCP 端口不能被重复占用。当一个 TCP 连接处于 TIME_WAIT 状态时，我们将无法立即使用该连接占用的端口来建立一个新连接

  如果没有 TIME_WAIT 状态，那么新的应用程序将占用这个刚刚释放的 TCP 端口建立新连接，新连接就有可能接收到属于原来连接的 TCP 报文段（迟到的报文段）

  因为 TCP 报文段的最大生存时间是 MSL，所以坚持 2MSL 时间的 TIME_WAIT 状态能够确保网络上两个传输方向上尚未被接收到、迟到的 TCP 报文段都已经消失（被中转路由器丢弃）。因此，一个复用了原来连接端口的新连接可以在 2MSL 时间之后安全地建立，而绝对不会接收到属于原来连接的数据，**这就是 TIME_WAIT 状态要维持 2MSL 时间的原因**

#### 强制占用 TIME_WAIT 状态的连接的端口

有时候，我们希望避免 TIME_WAIT 状态，因为当服务器程序退出后，我们希望能够立即重启它，但由于处在 TIME_WAIT 状态的连接还占用着端口，程序将无法启动（直到 2MSL 超时时间结束）

我们使用 `nc` 程序模拟客户端以固定端口 1234 登录本机的 Web 服务，然后从终端以 ctrl+c 终止客户端程序，接着又立即重启 nc 程序，以相同的方式连接本机 Web 服务：

```
$ nc -p 12345 127.0.0.1 80
ctrl+c
$ nc -p 12345 127.0.0.1 80
nc: bind failed: Address already in use  # 连接失败，端口 12345 仍然被上个连接占用
```

这时，使用 `netstat -nat` 查看连接状态，可以看到端口 12345 处于 TIME_WAIT 状态：

```
$ netstat -nat
tcp   0   0  192.168.1.108:12345  192.168.1.108:80  TIME_WAIT
```

- 对客户端来说，因为客户端一般使用系统自动分配的临时端口号建立连接，所以不需要担心上述问题
- 但是对服务器而言，服务器程序总是使用同一个知名服务端口号，所以其关闭后不能立即重启
  可以使用 socket 选项 `SO_REUSEADDR` 来强制进程立即使用处于 TIME_WAIT 状态的连接占用的端口

## 六、复位报文段

某些特殊条件下，TCP 连接的一端会向另一端发送携带 RST 标志的报文段，即复位报文段，以通知对方关闭连接或重新建立连接

3 种情况下会产生复位报文段：

- 访问不存在的端口或访问被处于 TIME_WAIT 状态连接占用的端口

  当客户端程序访问一个不存在的端口时，目标主机将给它发送一个复位报文段

  考虑从本机(192.168.1.109)上执行 `telnet` 命令登录目标机器（192.168.1.108）上一个不存在的 54321 端口，并用 `tcpdump` 抓取该过程中两台主机交换的 TCP 报文段：

  ```
  $ sudo tcpdump -nt -i eth0 port 54321
  $ telnet 192.168.1.108 54321  # 连接被拒绝
  ```

  telnet 程序发出的连接被拒绝，因为这个端口不存在，tcpdump 的输出如下：

  ```
  1. IP 192.168.1.109.42001 > 192.168.1.108.54321: Flags [S], seq 21621375, win 14600, length 0
  2. IP 192.168.1.108.54321 > 192.168.1.109.42001: Flags [R.], seq 0, ack 21621376, win 0, length 0
  ```

  报文段 2 为目标主机 108 向 主机 109 发送的复位报文段（R 标志），复位报文段的接收通告窗口大小为 0，所以收到复位报文段的一端应该关闭连接或者重新连接，而不能回应这个复位报文段

  当客户端访问的端口被处于 TIME_WAIT 状态的连接占用时，客户端程序也将收到复位报文段

- 异常终止连接

  应用程序可以通过使用 socket 选项 SO_LINGER 发送复位报文段来主动异常终止一个连接，一旦发送了复位报文段，发送端所有排队等待发送的数据都将被丢弃

- 处理半打开连接

  当 TCP 连接的一方关闭或异常终止了连接，而另一方没有接收到结束报文段（如发送了网络故障）。这时就会出现连接一方认为连接已关闭而另一方认为连接仍存在的情况，处于这种状态的连接被称为半打开连接。如果客户端或服务器往处于半打开状态的连接写入数据时，则对方将回应一个复位报文段

  我们在服务端 109 上使用 `nc` 命令模拟一个服务器程序，使之监听 12345 端口，然后再客户端 108 上用 `telnet` 命令登录该端口，然后拔掉客户端网线，并在服务端终端服务器程序

  此时，客户端上运行的 telnet 程序维持着一个半打开连接，然后接上服务端的网线，并从客户端程序往半打开连接写入 1 字节数据

  运行 `tcpdump` 程序抓取整个过程中 telnet 客户端和 nc 服务器交换的 TCP 报文段：

  服务端运行：
  ```
  $ nc -l 12345
  ```

  客户端运行：
  ```
  $ sudo tcpdump -nt -i eth0 port 12345
  $ telnet 192.168.1.109 12345
  Connected to 192.168.1.109
  Escape character is '^]'.   # 此时断开服务端网线，并重启服务器
  a(回车)                     # 向半打开连接输入字符 a
  Connection closed by foreign host.
  ```

  telnet 的输出显示：连接被服务器关闭了。tcpdump 抓取到的 TCP 报文段内容如下：

  ```
  1. IP 192.168.1.108.55100 > 192.168.1.109.12345: Flags [S], seq 3093809365, length 0
  2. IP 192.168.1.109.12345 > 192.168.1.108.55100: Flags [S.], seq 1495337791, ack 3093809366, length 0
  3. IP 192.168.1.108.55100 > 192.168.1.109.12345: Flags [.], ack 1, length 0
  4. IP 192.168.1.108.55100 > 192.168.1.109.12345: Flags [P.], seq 1:4, ack 1, length 3
  5. IP 192.168.1.109.12345 > 192.168.1.108.55100: Flags [R], seq 1495337792, length 0
  ```

  - 前 3 个 TCP 报文段是正常建立 TCP 连接的 3 次握手的过程
  - 第 4 个 TCP 报文段由客户端发送给服务器，它携带了 3 字节的应用程序数据
  - 由于服务器程序已经终端，所以服务器对客户端发送的数据回应了一个复位报文段 5

## 七、TCP 交互数据流和成块数据流

TCP 报文段所携带的应用程序数据按照长度分为两种：交互数据和成块数据

- 交互数据仅包含很少的字节，使用交互数据的应用程序（或协议）对实时性要求高，比如 telnet、ssh 等
- 成块数据的长度则通常为 TCP 报文段允许的最大数据长度，使用成块数据的应用程序（或协议）对传输效率要求高，比如 ftp

### 1. TCP 交互数据流

使用 `telnet` 命令登录本机，然后在 shell 命令提示符后执行 ls 命令，同时用 `tcpdump` 抓取这一过程中 telnet 客户端和 telnet 服务器交换的 TCP 报文段

```
$ tcpdump -nt -i lo port 23
$ telnet 127.0.0.1  # 输入用户名密码 登录成功之后输入 ls
```

仅列出我们感兴趣的、执行 ls 命令产生的 tcpdump 输出：

```
1. IP 127.0.0.1.58130 > 127.0.0.1.23: Flags [P.], seq 1408334812:1408334813,ack 1415955507, win 613, length 1
2. IP 127.0.0.1.23 > 127.0.0.1.58130: Flags [P.], seq 1:2, ack 1, win 512, length 1
3. IP 127.0.0.1.58130 > 127.0.0.1.23: Flags [.], ack 2, win 613, length 0
4. IP 127.0.0.1.58130 > 127.0.0.1.23: Flags [P.], seq 1:2, ack 2, win 613, length 1
5. IP 127.0.0.1.23 > 127.0.0.1.58130: Flags [P.], seq 2:3, ack 2, win 512, length 1 
6. IP 127.0.0.1.58130 > 127.0.0.1.23: Flags [.], ack 3, win 613, length 0 
7. IP 127.0.0.1.58130 > 127.0.0.1.23: Flags [P.], seq 2:4, ack 3, win 613, length 2 
8. IP 127.0.0.1.23 > 127.0.0.1.58130: Flags [P.], seq 3:176, ack 4, win 512, length 173 
9. IP 127.0.0.1.58130 > 127.0.0.1.23: Flags [.], ack 176, win 630, length 0 
10. IP 127.0.0.1.23 > 127.0.0.1.58130: Flags [P.], seq 176:228, ack 4, win 512, length 52
11. IP 127.0.0.1.58130 > 127.0.0.1.23: Flags [.], ack 228, win 630, length 0 
```

- TCP 报文段 1 由客户端发送给服务器，它携带 1 个字节的应用程序数据，即字母 “1"
- TCP 报文段 2 是服务器对 TCP 报文段 1 的确认，同时回显字母 “1”
- TCP 报文段 3 是客户端对 TCP 报文段 2 的确认
- 第 4~6 个 TCP 报文段是针对字母 “s" 的上述过程
- TCP 报文段 7 传送的 2 字节数据分别是：客户端键入的回车符和流结束符( EOP,本例中是 0x00)
- TCP 报文段 8 携带服务器返回的客户查询的目录的内容( ls 命令的输出)，包括该目录下文件的文件名及其显示控制参数
- TCP 报文段 9 是客户端对 TCP 报文段 8 的确认
- TCP 报文段 10 携带的也是服务器返回给客户端的数据，包括一个回车符、一个换行符、客户端登录用户的 PSI 环境变量
- TCP 报文段 11 是客户端对 TCP 报文段 10 的确认

#### 延迟确认

上述过程中，客户端针对服务器返回的数据所发送的确认报文段( TCP 报文段 6、9和11 )都不携带任何应用程序数据(长度为 0 ),而服务器每次发送的确认报文段(TCP报文段 2、5、8和10 )都包含它需要发送的应用程序数据。

服务器的这种处理方式称为 **延迟确认**，即它不马上确认上次收到的数据，而是在一段延迟时间后看本端是否有数据需要发送，如果有，则和确认信息一起发出，因为服务器对客户请求处理得很快，所以它发送确认报文段的时候总是有数据一起发送。 廷迟确认可以减少发送TCP报文段的数量、而由于用户的输入速度明显慢于客户端程序的处理速度，所以客户端的确认报文段总是不携带任何应用程序数据。

前面曾提到，在TCP连接的建立和断开过程中，也可能发生延迟确认。

#### Nagle 算法

上例是在本地回路运行的结果，在局城网中也能得到基本相同的结果，但在广城网就未必如此了。广城网上的交互数据流可能经受很大的延迟，并且，携带交互数据的微小 TCP 报文段数量一般很多(一个按键输人就导致一个 TCP 报文段)，这些因素都可能导致拥塞发生。

解决该问题的一一个简单有效的方法是使用 **Nagle算法**

Nagle 算法要求一个 TCP 连接的通信双方在任意时刻都最多只能发送一个未被确认的 TCP 报文段，在该 TCP 报文段的确认到达之前不能发送其他 TCP 报文段。另一方面，发送方在等待确认的同时收集本端需要发送的微量数据，并在确认到来时以一一个 TCP 报文段将它们全部发出。这样就极大地减少了网络上的微小 TCP 报文段的数量。

该算法的另一个优点在于其自适应性:确认到达得越快，数据也就发送得越快。


### 2. TCP 成块数据流

考虑用 FTP 协议传输一个大文件。在本地启动一个 `vstpd` 服务器程序，并执行 `ftp` 命令登录该服务器上，然后在 ftp 命令提示符后输入 get 命令，从服务器下载一个几百兆的大文件。同时用 `tpdump` 抓取这一个过程中 ftp 客户端和 vsftpd 服务器交换的 TCP 报文段：

```
$ sudo tepdump -nt -i etho port 20  # vsftpd服务器程序使用端口号20
$ ftp 127.0.0.1     # 输入用户名密码
ftp> get bigfille   # 获取大文件
```

下面是 `tcpdump` 的部分输出：

```
1. IP 127.0.0.1.20 > 127.0.0.1.39651: Flags [.], seq 205783041:205799425, ack 1, win 513, length 16384
2. IP 127.0.0.1.20 > 127.0.0.1.39651: Flags [.], seq 205799425:205815809, ack 1, win 513, length 16384 
3. IP 127.0.0.1.20 > 127.0.0.1.39651: Flags [.], seq 205815809:205832193, ack 1, win 513, length 16384 
4. IP 127.0.0.1.20 > 127.0.0.1.39651: Flags [P.], seq 205832193:205848577, ack 1, win 513, length 16384 
5. IP 127.0.0.1.20 > 127.0.0.1.39651: Flags [.], seq 205848577:205864961, ack 1, win 513, length 16384 
6. IP 127.0.0.1.20 > 127.0.0.1.39651: Flags [.], seq 205864961:205881345, ack 1, win 513, length 16384 
7. IP 127.0.0.1.20 > 127.0.0.1.39651: Flags [.], seq 205881345:205897729, ack 1, win 513, length 16384 
8. IP 127.0.0.1.20 > 127.0.0.1.39651: Flags [P.], seq 205897729:205914113, ack 1, win 513, length 16384 
9. IP 127.0.0.1.20 > 127.0.0.1.39651: Flags [.], seq 205914113:205930497, ack 1, win 513, length 16384 
10. IP 127.0.0.1.20 > 127.0.0.1.39651: Flags [.], seq 205930497:205946881, ack 1, win 513, length 16384
11. IP 127.0.0.1.20 > 127.0.0.1.39651: Flags [.], seq 205946881:205963265, ack 1, win 513, length 16384
12. IP 127.0.0.1.20 > 127.0.0.1.39651: Flags [P.], seq 205963265:205979649, ack l, win 513, length 16384
13. IP 127.0.0.1.20 > 127.0.0.1.39651: Flags [.], seq 205979649:205996033, ack l, win 513, length 16384
14. IP 127.0.0.1.20 > 127.0.0.1.39651: Flags [.], seq 205996033:206012417, ack 1, win 513, length 16384
15. IP 127.0.0.1.20 > 127.0.0.1.39651: Flags [.], seq 206012417:206028801, ack 1, win 513, length 16384
16. IP 127.0.0.1.20 > 127.0.0.1.39651: Flags [Р.], seq 206028801 :206045185, ack l, win 513, length 16384
17. IP 127.0.0.1.39651 > 127.0.0.1.20: Flags [.], ack 205815809, win 30084, length 0
18. IP 127.0.0.1.39651 > 127.0.0.1.20: Flags [.], ack 206045185, win 27317, length 0 
```

> 客户端发送的最后两个 TCP 报文段 17 和 18,它们分别是对 TCP 报文段 2 和 16 的确认(从序号值和确认值来判断)

由上面输出可见，**当传输大量大块数据的时候，发送方会连续发送多个TCP报文段，接收方可以一次确认所有这些报文段**。发送方在收到上一次确认后，能连续发送多少个TCP报文段由接收通告窗口(还需要考虑拥塞窗口)的大小决定。

> TCP 报文段 17 说明客户端还能接收 30084X64 字节(本例中窗口扩大因子为 6)，即 1925376 字节的数据。而在 TCP 报文段 18 中，接收通告窗口大小为 1748288 字节，即客户端能接收的数据量变小了。这表明客户端的TCP 接收缓冲区有更多的数据未被应用程序读取而停留在其中，这些数据都来自 TCP 报文段 3~16 中的一部分。服务器收到 TCP 报文段 18 后，它至少(因为接收通告窗口可能扩大)还能连续发送的未被确认的报文段数量是 1748288/16384 个，即 106 个(但一般不会连续发送这么多)。 其中，16384 是成块数据的长度(见 TCP 报文段1 ~16 的 length 值)，很显然它小于但接近 MSS 规定的 16396 字节。


另外，服务器每发送 4 个 TCP 报文段就传送一个 PSH 标志（Flags [P]）给客户端，以通知客户端的应用程序尽快读取数据。不过这对服务器来说显然不是必需的，因为它知道客户端的 TCP 接收缓冲区中还有空闲空间(接收通告窗口大小不为 0)。

我们可以修改系统的 TCP 接收缓冲区和 TCP 发送缓冲区的大小，使之都为4096字节，然后重启 vsftpd 服务器，并再次执行上述操作。`tcpdump` 的部分输出如下：

```
1. IP 127.0.0.1.20 > 127.0.0.1.45227: Flags [.], seq 5195777:5197313, ack 1, win 3072，length 1536
2. IP 127.0.0.1.20 > 127.0.0.1.45227: Flags [.]， seq 5197313:5198849, ack 1, win 3072, length 1536
3. IP 127.0.0.1.45227 > 127.0.0.1.20: Flags [.]， ack 5198849, win 3072, length 0
4. IP 127.0.0.1.20 > 127.0.0.1.45227: Flags [P.], seq 5198849:5200385, ack 1, win 3072， length 1536
5. IP 127.0.0.1.45227 > 127.0.0.1.20: Flags [.]， ack 5200385， win 3072， length 0
```

本次通信过程中，客户端和服务器的窗口扩大因子都设为 0，因此客户端和服务器每次通告的窗口大小都是 3072 字节(没超过 4096 字节)。因为每个成块数据的长度为 1536 字节，所以服务器在收到上一个 TCP 报文段的确认之前最多还能再发送 1 个 TCP 报文段，这正是 TCP 报文段 1~3 描述的情形。

## 八、带外数据

### 1. 什么是带外数据

带外(Out of Band, 00B)数据，用于迅速通告对方本端发生的重要事件。带外数据比普通数据(也称为带内数据)有更高的优先级，它应该总是立即被发送，而不论发送缓冲区中是否有排队等待发送的普通数据。带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接中。

### 2. TCP 中如何发送带外数据

UDP 没有实现带外数据传输，TCP 也没有真正的带外数据。不过 TCP 在传输普通数据时利用其头部中的 **紧急指针标志和紧急指针** 两个字段来传输紧急数据，这种紧急数据的含义和带外数据类似

#### TCP发送带外数据的过程

假设一个进程已经往某个 TCP 连接的发送缓冲区中写人了 N 字节的普通数据，并等待其发送。在数据被发送前，该进程又向这个连接写入了 3 字节的带外数据 “abc"。此时，待发送的 TCP 报文段的头部将被设置 URG 标志，并且紧急指针被设置为指向最后一个带外数据的下一字节（进一步减去当前 TCP 报文段的序号值得到其头部中的紧急偏移值），如下图所示：

<div align="center"><image src="../doc/TCP发送缓冲区中的紧急数据.png"></image></div>

由上图可见，发送端一次发送的多字节的带外数据中只有最后一个字节被当作带外数据（字母 c）,而其他数据（字母 a 和 b）被当成了普通数据。如果 TCP 模块以多个 TCP 报文段来发送上图中所示 TCP 发送缓冲区中的内容，则每个 TCP 报文段都将设置 URG 标志， 并且它们的紧急指针指向同一个位置(数据流中带外数据的下一一个位置)， 但只有一个 TCP 报文段真正携带带外数据。

#### TCP 接收带外数据的过程

TCP 接收端只有在接收到紧急指针标志时才检查紧急指针，然后根据紧急指针所指的位置确定带外数据的位置：

- 默认情况下，TCP 模块会将带外数据读入一个特殊的缓存中。这个缓存只有 1 字节，称为 **带外缓存**。如果上层应用程序没有及时将带外数据从带外缓存中读出，则后续的带外数据将覆盖它

- 但是如果给 TCP 连接设置了 SO_OOBINLINE 选项，则带外数据将和普通数据一样被 TCP 模块存放在 TCP 接收缓冲区中。此时应用程序需要像读取普通数据一样来读取带外数据。这种情况下，紧急指针可以用来指出带外数据的位置，socket 编程接口也提供了系统调用来识别带外数据

## 九、TCP 超时重传

在异常网络状况下（出现发送超时或丢包），TCP 通过 **超时重传** 机制来保证其承诺的可靠服务。

### 1. 超时重传机制

如果在超时时间内未收到确认的 TCP 报文段，TCP服务必须能够重传该 TCP 报文段。

为此，TCP 模块为每个 TCP 报文段都维护了一个重传定时器，该定时器在 TCP 报文段第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP 模块将重传 TCP 报文段并重置定时器。一般 TCP 模块会超时重传多次，每次重传的时间间隔都增加一倍，重传次数与 Linux 中两个重要的内核参数有关：

- `/proc/sys/net/ipv4/tcp_ retries1` 指定在底层 IP 接管之前 TCP 最少执行的重传次数，默认值是3
- `/proc/sys/net/ipv4/tcp_ retries2` 指定连接放弃前 TCP 最多可以执行的重传次数，默认值是 15 (一般对应 13~30min)

若多次重连仍无响应，则放弃连接并交由 IP 或 ARP 协议处理

### 2. 使用 tcpdump 观察超时重传机制

在服务器 108 上启动 `iperf` 服务器程序，从客户端 109 上执行 `telnet` 命令登录该服务器程序，然后，先从 telnet 客户端发送数据 "1234" 给服务器，然后断开服务器网线并再次从客户端发送 "12" 给服务器

同时，使用 `tcpdump` 抓取过程中客户端和服务器间交换的 TCP 报文段：

```
$ sudo tcpdump -n -i eth0 port 5001
$ iperf -s
$ telnet 192.168.1.108 5001
```

> iperf是一个测量网络状况的工具，-s 选项表示将其作为服务器运行。iperf 默认监听 5001 端口，并丢弃该端口上接收到的所有数据，相当于一个discard服务器

tcpdump 输出如下：

```
1. 18:44:57.580341 IP 192.168.1.109.38234 > 192.168.1.108.5001: Flags [S], seq 2381272950, length 0
2. 18:44:57.580477 IP 192.168.1.108.5001 > 192.168.1.109.38234: Flags [S.], seq 466032301, ack 2381272951, length 0 
3. 18:44:57.580498 IP 192.168.1.109.38234 > 192.168.1.108.5001: Flags [.],  ack 1, length 0 
4. 18:44:59.866019 IP 192.168.1.109.38234 > 192.168.1.108.5001: Flags [P.], seq 1:7, ack 1, length 6
5. 18:44:59.866165 IP 192.168.1.108.5001 > 192.168.1.109.38234: Flags [.], ack 7, length 0 
6. 18:45:25.028933 IP 192.168.1.109.38234 > 192.168.1.108.5001: Flags [P.], seq 7:11, ack 1, length 4
7. 18:45:25.230034 IP 192.168.1.109.38234 > 192.168.1.108.5001: Flags [P.], seq 7:11, ack 1, length 4 
8. 18:45:25.639407 IP 192.168.1.109.38234 > 192.168.1.108.5001: Flags [P.], seq 7:11, ack 1, length 4 
9. 18:45:26.455942 IP 192.168.1.109.38234 > 192.168.1.108.5001: Flags [P.], seq 7:11, ack 1, length 
10. 18:45:28.092425 IP 192.168.1.109.38234 > 192.168.1.108.5001: Flags [P.], seq 7:11, ack 1, length 4 
11. 18:45:31.362473 IP 192.168.1.109.38234 , 192.168.1.108.5001: Flags [P.], seq 7:11, ack 1, length 4 
12. 18:45:33.100888 ARP, Request who-has 192.168.1.108 tell 192.168.1.109, length 28 
13. 18:45:34.098156 ARP, Request who-has 192.168.1.108 tell 192.168.1.109, length 28 
14. 18:45:35.100887 ARP, Request who-has 192.168.1.108 tell 192.168.1.109, length 28 
15. 18:45:37.902034 ARP, Request who-has 192.168.1.108 tell 192.168.1.109, length 28 
16. 18:45:38.903126 ARP, Request who-has 192.168.1.108 tell 192.168.1.109, length 28 
17. 18:45:39.901421 ARP, Request who-has 192.168.1.108 tell 192.168.1.109, length 28 
18. 18:45:44.440049 ARP, Request who-has 192.168.1.108 tell 192.168.1.109, length 28 
19. 18:45:45.438840 ARP, Request who-has 192.168.1.108 tell 192.168.1.109, length 28 
20. 18:45:46.439932 ARP, Request who-has 192.168.1.108 tell 192.168.1.109, length 28 
21. 18:45:50.976710 ARP, Request who-has 192.168.1.108 tell 192.168.1.109, length 28 
22. 18:45:51.974134 ARP, Request who-has 192.168.1.108 tell 192.168.1.109, length 28 
23. 18:45:52.973939 ARP, Request who-has 192.168.1.108 tell 192.168.1.109, length 28 
```

- TCP 报文段 1~3 是三次握手建立连接的过程
- TCP 报文段 4~5 是客户端发送数据 “1234” (应用程序数据长度为6，包括回车、换行两个字符)及服务器确认的过程
- TCP 报文段 6 是客户端第一次发送数据 “12” 的过程。因为服务器的网线被断开，所以客户端无法收到 TCP 报文段 6 的确认报文段
- TCP 报文段 7~11 是客户端对 TCP 报文段 6 执行了 5 次重传，这可以从每个 TCP 报文段的序号得知
- 数据包 12~23 都是 ARP 模块的输出内容，即客户端查询服务器的 MAC 地址

从 tcpdump 输出的时间戳可以看到 TCP 报文段 6~11 被发送的时间间隔，它们分别为0.2s、0.4s、0.8s、1.6s、3.2s。由此可见，TCP 连接一共执行 5 次重传，每次重传超时时间都增加一倍

在 5 次重传均失败的情况下，底层的 IP 和 ARP 开始接管，直到 telnet 客户端放弃连接为止


虽然超时会导致TCP报文段重传，但TCP报文段的重传可以发生在超时之前，即快速重传，这将在下一节中讨论。

## 十、TCP 拥塞控制

### 1. 拥塞控制概述

TCP 拥塞控制的目的是 **提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性**

TCP拥塞控制包含四部分内容:慢启动(slow start)、拥塞避免(congestion avoidance)、快速重传(fast retransmit)和快速恢复(fastrecovery)

拥塞控制算法在Linux下有多种实现，比如reno算法、vegas算法和cubic算法等。它们或者部分或者全部实现了上述四个部分。`/proc/sys/netipv4/tcp_congestion_control` 文件指示机器当前所使用的拥塞控制算法

拥塞控制的最终受控变量是发送端向网络一次连续写入（收到其中第一个数据的确认之前）的数据量，我们称为 SWND (Send Window,发送窗口)。不过，发送端最终以 TCP 报文段来发送数据，所以 SWND 限定了发送端能连续发送的 TCP 报文段数量。这些 TCP 报文段的最大长度(仅指数据部分)称为 SMSS (Sender Maximum Segment Size,发送者最大段大小)，其值一般等于 MSS.

发送端需要合理地选择SWND的大小：

- 如果SWND太小，会引起明显的网络延迟
- 如果SWND太大，则容易导致网络拥塞

前面说到，接收方可通过其接收通告窗口（RWND）来控制发送端的 SWND，但这显然不够，所以发送端引人了一个称为拥塞窗口（Congestion Window, CWND）的状态变量。实际的 SWND 值是 RWND 和 CWND 中的较小者。下图展示了拥塞控制的输人和输出(可见，它是个闭环反馈控制)：

<div align="center"><image src="../doc/拥塞控制的输入输出.png"></image></div>

### 2. 拥塞控制状态转移

和 TCP 一样，拥塞控制算法也有其状态机，当发送方收到一个 Ack 时，Linux TCP 通过状态机（state）来决定其接下来的行为，是应该降低拥塞窗口 cwnd 大小，或者保持 cwnd 不变，还是继续增加 cwnd。如果处理不当，可能会导致丢包或超时

<div align="center"><image src="../doc/TCP拥塞控制状态机.png"></image></div>

- open 状态

Open 状态是拥塞控制状态机的默认状态。这种状态下，当 ACK 到达时，发送方根据拥塞窗口 cwnd(Congestion Window) 是小于还是大于慢启动阈值 ssthresh(slow start threshold)，来按照慢启动或者拥塞避免算法来调整拥塞窗口。

- disorder 状态

当发送方检测到 DACK (重复确认)或者 SACK (选择性确认)时，状态机将转变为 Disorder 状态。在此状态下，发送方遵循飞行 (in-flight) 包守恒原则，即一个新包只有在一个老包离开网络后才发送，也就是发送方收到老包的 ACK 后，才会再发送一个新包。

- CWR 状态

发送方接收到一个拥塞通知时，并不会立刻减少拥塞窗口 cwnd，而是每收到两个 ACK 就减少一个段，直到窗口的大小减半为止。当 cwnd 正在减小并且网络中有没有重传包时，这个状态就叫 CWR (Congestion Window Reduced，拥塞窗口减少)状态。CWR 状态可以转变成 Recovery 或者 Loss 状态。

- Recovery 状态

当发送方接收到足够(推荐为三个)的 DACK (重复确认)后，进入该状态。在该状态下，拥塞窗口 cnwd 每收到两个 ACK 就减少一个段(segment)，直到 cwnd 等于慢启动阈值 ssthresh，也就是刚进入 Recover 状态时 cwnd 的一半大小。

发送方保持 Recovery 状态直到所有进入 Recovery 状态时正在发送的数据段都成功地被确认，然后发送方恢复成 Open 状态，重传超时有可能中断 Recovery 状态，进入 Loss 状态。

- Loss 状态

当一个 RTO(重传超时时间)到期后，发送方进入 Loss 状态。所有正在发送的数据标记为丢失，拥塞窗口 cwnd 设置为一个段(segment)，发送方再次以慢启动算法增大拥塞窗口 cwnd

Loss 和 Recovery 状态的区别是:Loss 状态下，拥塞窗口在发送方设置为一个段后增大，而 Recovery 状态下，拥塞窗口只能被减小。Loss 状态不能被其他的状态中断，因此，发送方只有在所有 Loss 开始时正在传输的数据都得到成功确认后，才能退到 Open 状态。

### 3. 拥塞控制四大部分：慢启动、拥塞避免、拥塞发生、快速恢复

#### 慢启动

所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序

慢启动算法：

1) 连接建好的开始先初始化拥塞窗口 cwnd 大小为 1，表明可以传一个 MSS 大小的数据。
2) 每当收到一个 ACK，cwnd 大小加 1(cwnd 增长单位为MSS)，呈线性上升。
3) 每当过了一个往返延迟时间 RTT(Round-Trip Time)，cwnd 大小直接翻倍，乘以 2，呈指数上升。
4) 还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd >= ssthresh 时，就会进入“拥塞避免算法”

#### 拥塞避免

如前所述，当拥塞窗口大小 cwnd 大于等于慢启动阈值 ssthresh 后，就进入拥塞避免算法。算法如下：

1) 收到一个 ACK，则 cwnd = cwnd + 1 / cwnd
2) 每当过了一个往返延迟时间 RTT，cwnd 大小加 1

 过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。


#### 拥塞发生

一般来说，TCP 拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的 TCP 拥塞控制算法以丢包为网络进入拥塞状态的信号。对于丢包有两种判定方式：

- 一种是重传超时，或者说 TCP 重传定时器溢出
- 另一个是收到三个重复确认ACK

拥塞控制对这两种情况有不同的处理方式：

- 对第一种情况 仍然使用慢启动和拥塞避免。
- 对第二种情况则使用快速重传和快速恢复( 如果是真的发生拥塞的话)。

> 注意，第二种情况如果发生在重传定时器溢出之后，也被拥塞控制当成第一种情况来对待

如果发送端接收到 3 个以上的重复 ACK，TCP 就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫做快速重传，而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法。

如果发送端检测到拥塞发生是由于传输超时，即上述第一种情况。那么它将执行重传并做如下调整：

- 由于发生丢包，将慢启动阈值 ssthresh 设置为当前 cwnd 的一半，即 ssthresh = cwnd / 2
- cwnd 重置为 1
- 进入慢启动过程

因为早期的 TCP Tahoe 算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd又重置为1，十分不利于网络数据的稳定传递。

所以，TCP Reno 算法进行了优化。当收到三个重复确认 ACK 时，TCP 开启快速重传 Fast Retransmit 算法，而不用等到 RTO 超时再进行重传：

- cwnd 大小缩小为当前的一半
- ssthresh 设置为缩小后的 cwnd 大小
- 然后进入快速恢复算法 Fast Recovery

<div align="center"><image src="../doc/TCP拥塞控制过程图.png"></image></div>

#### 快速恢复


TCP Tahoe 是早期的算法，所以没有快速恢复算法，而Reno算法有。

在进入快速恢复之前，cwnd 和 ssthresh 已经被更改为原有 cwnd 的一半。快速恢复算法的逻辑如下：

- cwnd = cwnd + 3 MSS，加3 MSS的原因是因为收到3个重复的ACK。
- 重传DACKs指定的数据包。
- 如果再收到DACKs，那么cwnd大小增加一。
- 如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。

下图为重传示意图：

<div align="center"><image src="../doc/TCP拥塞控制快速恢复重传示意图.png"></image></div>

 如图所示，第五个包发生了丢失，所以导致接收方接收到三次重复 ACK，也就是ACK5。所以将 ssthresh 设置当当时 cwnd 的一半，也就是 6/2 = 3，cwnd 设置为 3 + 3 = 6。然后重传第五个包。当收到新的 ACK 时，也就是 ACK11，则退出快速恢复阶段，将 cwnd 重新设置为当前的 ssthresh，也就是 3，然后进入拥塞避免算法阶段

## 十一、TCP 问题

### 未完待续



参考：

- 《Linux高性能服务器编程》
- [TCP 拥塞控制算法](https://segmentfault.com/a/1190000018360050)
- [万字长文｜全(小区局域)网最强 TCP/IP 拥塞控制总结](https://baijiahao.baidu.com/s?id=1668851725425101977&wfr=spider&for=pc)
- [什么是TCP粘包？怎么解决这个问题](https://blog.csdn.net/weixin_41047704/article/details/85340311)
- [从 TCP 三次握手说起：浅析TCP协议中的疑难杂症 ( 1 )](https://cloud.tencent.com/developer/article/1004327)
- [从 TCP 三次握手说起：浅析TCP协议中的疑难杂症 ( 2 )](https://cloud.tencent.com/developer/article/1004336)