# TCP协议

<!-- TOC -->

- [一、TCP 协议的主要内容](#一tcp-协议的主要内容)
- [二、TCP 服务特点](#二tcp-服务特点)
    - [1. 面向连接](#1-面向连接)
    - [2. 字节流](#2-字节流)
    - [3. 可靠传输](#3-可靠传输)
- [三、TCP 头部结构](#三tcp-头部结构)
    - [1. 固定头部](#1-固定头部)
    - [2. 头部选项字段](#2-头部选项字段)
    - [3. 使用 tcpdump 观察 TCP 头部信息](#3-使用-tcpdump-观察-tcp-头部信息)
- [四、TCP 连接的建立和关闭——三次握手四次挥手](#四tcp-连接的建立和关闭三次握手四次挥手)
    - [1. 利用 tcpdump 观察 TCP 连接的建立和关闭](#1-利用-tcpdump-观察-tcp-连接的建立和关闭)
        - [三次握手过程](#三次握手过程)
        - [四次挥手过程](#四次挥手过程)
    - [2. 半关闭状态](#2-半关闭状态)
    - [3. 连接超时](#3-连接超时)
- [四、TCP 状态转移](#四tcp-状态转移)
    - [1. TCP 状态转移总图](#1-tcp-状态转移总图)
    - [2. TIME_WAIT 状态](#2-time_wait-状态)
        - [为什么要有需要等待 2MSL 时间的 TIME_WAIT 状态？](#为什么要有需要等待-2msl-时间的-time_wait-状态)
        - [强制占用 TIME_WAIT 状态的连接的端口](#强制占用-time_wait-状态的连接的端口)
- [五、复位报文段](#五复位报文段)
- [六、TCP 交互数据流和成块数据流](#六tcp-交互数据流和成块数据流)
    - [1. TCP 交互数据流](#1-tcp-交互数据流)
        - [延迟确认](#延迟确认)
        - [Nagle 算法](#nagle-算法)
    - [2. TCP 成块数据流](#2-tcp-成块数据流)
- [七、带外数据](#七带外数据)
- [八、拥塞控制](#八拥塞控制)

<!-- /TOC -->

## 一、TCP 协议的主要内容

TCP 协议是 TCP/IP 协议的一个重要的协议，TCP 协议属于传输层协议，更加靠近应用层。 TCP 协议主要从以下四个方面讨论：

- `TCP 头部信息`

  TCP 头部信息出现在每个 TCP 报文段中，用于指定通信的源端口号、目的端口号、管理 TCP 连接、控制两个方向的数据流

- `TCP 状态转移过程`

  TCP 连接的任意一端都是一个状态机。在 TCP 连接从建立到断开的整个过程中，连接两端的状态机经历不过的状态变迁

- `TCP 数据流`

  讨论两种类型的 TCP 数据流：交互数据流和成块数据流。还有各种特殊的紧急数据

- `TCP 数据流的控制`

  为了保证可靠传输和提高网络通信质量，内核需要对 TCP 数据流进行两种控制：超时重传和拥塞控制

## 二、TCP 服务特点

传输层协议主要有两个：TCP 协议和 UDP 协议。TCP 协议相对于 UDP 协议的特点是：**面向连接、字节流、可靠传输**

### 1. 面向连接

使用 TCP 协议通信的双方必须 **先建立连接**，然后才能开始数据的读写，双方都必须为该连接分配必要的内核资源，以管理连接的状态和连接上数据的传输。TCP 连接是全双工的，即双方的数据读写可以通过一个连接进行。完成数据交换之后，通信双方都必须断开连接以释放系统资源

TCP 协议的连接是 **一对一** 的，所以 **基于广播和多播（目标是多个主机地址）的应用不能使用 TCP 服务**，而无连接协议 UDP 非常适合广播和多播

### 2. 字节流

TCP 数据传送是基于数据流服务的，而 UDP 基于数据报服务。

数据流服务和数据报服务的区别在实际编程中表现为通信双方是否必须执行相同次数的读、写操作

- TCP 读写数据

  当发送端应用程序连续多次写操作时，TCP 模块先将这些数据放入 TCP 发送缓冲区中，当 TCP 模块真正开始发送数据时，发送缓冲区中等待发送的数据会被封装成一个或多个 TCP 报文发出。因此 **TCP 模块发送出的 TCP 报文个数和应用程序执行的写操作之间没有固定的数量关系**

  当接收端收到一个或多个 TCP 报文后，TCP 模块先将其携带的应用程序数据按照报文序号依次放入 TCP 接受缓冲区中，并通知应用程序读取数据。接收端应用程序可以一次性将 TCP 接受缓冲区中的数据全部读出，也可以分多次读取，这取决于用户指定的应用程序读缓冲区的大小。因此 **应用程序执行的读操作和 TCP 模块接收到的 TCP 报文个数之间也没有固定的数量关系**

  综上，发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系，这就是字节流的概念

- UDP 读写数据

  UDP 则不然，发送端应用程序每执行一次写操作，UDP 模块就将其封装成一个 UDP 数据报并发送之。接收端必须及时针对每个 UDP 数据报执行读操作，否则就会丢包，并且，如果用户没有指定足够的应用程序缓冲区来读取 UDP 数据，则 UDP 数据将被截断

<div align="center"><image src="../doc/TCP字节流服务和UDP数据报服务区别.png"></image></div>

### 3. 可靠传输

TCP 传输通过 **发送应答、超时重传、重排整理** 等机制保证可靠性

- 发送应答

  发送端发送的每个 TCP 报文段必须得到接收方的应答，才认为这个 TCP 报文段传输成功

- 超时重传

  发送端在发送出一个 TCP 报文段后启动定时器，如果在定时时间内未收到应答，它将重发该报文段

- 重排整理

  因为 TCP 报文段最终是以 IP 数据报发送的，而 IP 数据报到达接收端可能会乱序、重复，所以 TCP 协议还会对接收到的 TCP 报文段进行重排、整理，再交付给应用层

## 三、TCP 头部结构

TCP 头部信息主要包括通信源端端口、目的端端口、用于管理 TCP 连接的信息等

### 1. 固定头部

<div align="center"><image src="../doc/TCP头部结构.png"></image></div>

- `16 位端口号`

  - `源端口号`：告知主机该报文段来自哪里
  - `目的端口号`：告知主机该报文段传给哪个上层协议或应用程序

  进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号，所有知名服务端口号都定义在 `/etc/services` 文件中

- `32 位序号`：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号

  假设主机 A 和 主机 B 进行 TCP 通信， A 发送给 B 的第一个 TCP 报文段中，序号值被系统初始化为某个随机值 ISN(Initial Sequence Number，初始序号值)。那么在该传输方向上（从 A 到 B），后续的 TCP 报文段中序号值将被系统设置为 ISN 加上该报文段所携带数据的第一个字节在整个字节流中的偏移

  > 例如，某个 TCP 报文段传送的数据是字节流中的第 1025~2048 字节，那么该报文段的序号值就是 ISN+1025。另外一个传输方向（从 B 到 A）的 TCP 报文段的序号值也具有相同的含义

- `32 位确认号`：用作对另一方发送来的 TCP 报文段的相应，其值被设为收到的 TCP 报文段的序号值加 1

  假设主机 A 和主机 B 进行 TCP 通信，那么 A 发送出的 TCP 报文段不仅携带自己的序号，而且包含对 B 发送来的 TCP 报文段的确认号，反之，B 发送出的 TCP 报文段也同时携带自己的序号和对 A 发送来的报文段的确认号

- `4 位头部长度`：标识该 TCP 头部有多少个 32 bit 字( 4 字节)，因为 4 位最大能表示 15，所以 TCP 头部最长是 60 字节

- `6 位标志位`：

  - `URG`：表示紧急指针是否有效
  - `ACK`：表示确认号是否有效，携带 ACK 标志的 TCP 报文段为确认报文段
  - `PSH`：提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，他们就会一直停留在 TCP 接收缓冲区）
  - `RST`：表示要求对方重新建立连接，携带 RST 标志的为复位报文段
  - `SYN`：表示请求建立一个连接，携带 SYN 标志的为同步报文段
  - `FIN`：表示通知对方本段要关闭连接了，携带 FIN 标志的为结束报文段

- `16 位窗口大小`：是用于 TCP 实现流量控制的

  窗口指接收通告窗口(Receiver Window, RWND)。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度

- `16 位校验和`：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以检验 TCP 报文段在传输过程中是否损坏

  注意：这个校验不仅包括 TCP 头部，也包括数据部分，是 TCP 可靠传输的重要保障

- `16 位紧急指针`：是一个正的偏移量，表示紧急指针相对于当前序号的偏移

  TCP 的紧急指针是发送端向接收端发送紧急数据的方法，它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号


### 2. 头部选项字段

TCP 头部的最后一个选项字段是可变长的可选信息。这部分最多包含 40 字节，因为 TCP 头部最长是 60 字节（包含 20 字节的固定部分）

选项字段结构图如下：

<div align="center"><image src="../doc/TCP头部选项字段结构.png"></image></div>

- `kind`：说明选项的类型。有的 TCP 选项没有后面两个字段，仅包含 1 字节的 kind 字段
- `length`：指定该选项的总长度，包括 kind 字段和 length 字段占据的 2 字节
- `info`：是选项的具体信息

常见的 TCP 选项有 7 种：

<div align="center"><image src="../doc/7种TCP选项.png"></image></div>

- `kind = 0`：选项表结束选项
- `kind = 1`：空操作选项，没有特殊含义，一般用于将 TCP 选项的总长度填充为 4 字节的整数倍
- `kind = 2`：最大报文段长度选项，通信双方使用该选项来协商最大报文段长度(Max Segment Size, MSS)
  TCP 模块通常将 MSS 设置为 MTU-40 字节（减掉的 40 字节包括 20 字节的 TCP 头部和 20 字节的 IP 头部）。这样是为了尽可能避免本机发生 IP 分片，对以太网而言，MSS 值是 1460(1500-40) 字节
- `kind = 3`：窗口扩大因子选项，TCP 连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子
  在 TCP 头部中，接收通告窗口大小是用 16 位表示的，故最大为 65535 字节，但实际上 TCP 模块允许的接收通告窗口大小远不止这个数（为了提高 TCP 通信的吞吐量）。窗口扩大因子解决了这个问题。

  假设 TCP 头部中的接收通告窗口大小是 N，窗口扩大因子是 M，那么 TCP 报文段的实际接收通告窗口大小为 N*2<sup>M</sup>，或者说 N 左移 M 位，M 的取值范围为 0~14
  
  可以通过修改 `/proc/sys/net/ipv4/tcp_window_scaling` 内核变量来启用或关闭窗口扩大因子选项

  窗口扩大因子选项和 MSS 选项都只能出现在同步报文段中，否则将被忽略。同步报文本身不执行窗口扩大的操作，即同步报文段头部的接收通告窗口大小就是该 TCP 报文段的实际接收通告窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了

- `kind = 4`：选择性确认选项（Selective Acknowledement, SACK）

  TCP 通信时，如果某个 TCP 报文段丢失，则 TCP 模块会重传最后被确认的 TCP 报文段后续的所有报文段，这样原先已经正确传输的 TCP 报文段也可能重复发送，从而降低了 TCP 性能

  SACK 技术改善这种情况，使 TCP 模块只重新发送丢失的 TCP 报文段，不用发送所有未被确认的 TCP 报文段。选择性确认选项在连接初始化时，表示是否支持 SACK 技术

  可以通过修改 `/proc/sys/net/ipv4/tcp_sack` 内核变量来启用或关闭选择性确认选项

- `kind = 5`：是 SACK 实际工作的选项，该选项的参数告诉发送方本段已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块

  每个块边沿(edge of block)参数包含一个 4 字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿表示不连续块的最后一个数据的序号的下一个序号，这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用 8 字节，所以 TCP 头部选项中实际最多可以包含 4 个这样的不连续数据块（类型和长度占用 2 字节）

- `kind = 8`：时间戳选项，该选项提供了较为准确的计算通信双方之间的回路时间（Round Trip Time，RTT）的方法，为 TCP 流量控制提供了重要信息

  可以通过修改 `/proc/sys/net/ipv4/tcp_timestamps` 内核变量来启用或关闭时间戳选项

### 3. 使用 tcpdump 观察 TCP 头部信息

我们利用分析 [IP协议](IP协议.md) 时抓取的 TCP 数据包对 TCP 协议相关部分进行分析：

```
IP 127.0.0.1.38560 > 127.0.0.1.23: Flags [S], seq 4242890062, win 65495, options [mss 65495,sackOK,TS val 3913303147 ecr 0,nop,wscale 7], length 0                                                                
        0x0000:  4510 003c ca49 4000 4006 7260 7f00 0001                                                 
        0x0010:  7f00 0001 96a0 0017 fce5 5d4e 0000 0000                                                 
        0x0020:  a002 ffd7 fe30 0000 0204 ffd7 0402 080a                                                 
        0x0030:  e940 446b 0000 0000 0103 0307
```

- `Flags [S]` ：表示该 TCP 报文段包含 SYN 标志，是一个同步报文段，如果 TCP 报文段包含其他标志，则 tcpdump 会将标志首字母显示在 Flags 后的方括号中
- `seq 4242890062`：序号值，因为该同步报文段是通信双方发送的第一个 TCP 报文段，所以这个序号值就是此次通信过程中该传输方向的 ISN 值，而且，由于是第一个 TCP 报文段，所以它没有针对对方发送来的 TCP 报文段的确认值（表示尚未收到任何对方来的 TCP 报文段）
- `win 65495`：表示接收通告窗口的大小，因为这是一个同步报文段，所以 win 值反映的是实际的接收通告窗口大小
- `options [...]`：是 TCP 选项，其具体内容在 `"[]"` 内
  - `mss 65495`：发送端通告的最大报文段长度
  - `sackOK`：表示发送端支持并同意使用 SACK 选项
  - `TS val 3913303147`：发送端的时间戳
  - `ecr 0`：时间戳回显应答，因为是一次 TCP 通信的第一个 TCP 报文段，所以它针对对方的时间戳的应答为 0（表示尚未收到对方的时间戳）
  - `nop`：表示空操作选项
  - `wscale 7`：指出发送端使用的窗口扩大因子为 7

接下来分析 tcpdump 输出的字节码中 TCP 头部对应的信息，从第 21 个字节开始，前 20 字节为 IP 头部：

| 十六进制数 | 十进制表示 | TCP 头部信息 |
| --- | --- | --- |
| 0x96a0 | 38560 | 16 位源端口号 |
| 0x0017 | 23 | 16 位目的端口号 |
| 0xfce55d4e | ‭4242890062‬ | 32 位序号 |
| 0x00000000 | 0 | 32 位确认号 |
| 0xa | 10 | 4 位头部长度，长度为 10 个 32 位（40 字节） | 
| 0x002 |  |  设置了 SYN 标志 |
| 0xffd7 | ‭65495‬ | 16 位接收通告窗口大小 |
| 0xfe30 |  | 16 位校验和 |
| 0x0000 |  | 16 位紧急指针，没设置 URG 标志，紧急指针无意义 |
| 0x0204 |  | 最大报文段长度选项的 kind 值和 length 值 |
| 0xffd7 | ‭65495‬ | 最大报文段长度 |
| 0x0402 |  | 允许 SACK 选项 |
| 0x080a |  | 时间戳选项的 kind 值和 length 值 |
| 0xe940446b | ‭3913303147‬ | 时间戳 |
| 0x00000000 | 0 | 回显应答时间戳 |
| 0x01 |  | 空操作选项 |
| 0x0303 |  | 窗口扩大因子选项的 kind 值和 length 值 |
| 0x07 | 7 | 窗口扩大因子为 7 |

从上表可以看出，TCP 报文段头部的二进制码和 tcpdump 输出的 TCP 报文段描述信息完全对应

## 四、TCP 连接的建立和关闭——三次握手四次挥手

### 1. 利用 tcpdump 观察 TCP 连接的建立和关闭

在本机(192.168.1.108)上使用 `telnet` 命令登录 `192.168.1.109` 的 80 端口，然后使用 `tcpdump` 抓取这个过程中客户端和服务器交换的 TCP 报文段

使用 `tcpdump` 抓取数据：

```
sudo tcpdump -i eth0 -nt '(src 192.168.1.109 and dst 192.168.1.108) or (src 192.168.1.108 and dst 192.168.1.109)'
```

在另一个终端上使用 `telnet` 登录 `192.168.1.109` 的 80 端口，连接成功会退出：

```
telnet 192.168.1.109 80
Trying 192.168.1.109...
Connected to 192.168.1.109.
Escape character is '^]'.
^]（回车） # 输入 ctrl + ] 并回车

telnet> quit（回车）
Connection closed.
```

上面 telnet 命令实现了 TCP 连接的建立到关闭的过程，`tcpdump` 的输出如下：

```
1. IP 192.168.1.108.60871 > 192.168.1.109.80: Flags [S], seq 535734930, win 5840, length 0
2. IP 192.168.1.109.80 > 192.168.1.108.60871: Flags [S.], seq 2159701207, ack 535734931, win 5792, length 0
3. IP 192.168.1.108.60871 > 192.168.1.109.80: Flags [.], ack 1, win 92, length 0
4. IP 192.168.1.108.60871 > 192.168.1.109.80: Flags [F.], seq 1, ack 1, win 92, length 0
5. IP 192.168.1.109.80 > 192.168.1.108.80971: Flags [.], ack 2, win 91, length 0
6. IP 192.168.1.109.80 > 192.168.1.108.80971: Flags [F.], seq 1, ack 2, win 91, length 0
7. IP 192.168.1.108.60871 > 192.168.1.109.80: Flags [.], ack 2, win 92, length 0
```

整个过程没有发生应用层数据的交换，所以 TCP 报文段的数据部分的长度（length）总是 0，可以将上面的过程绘制成下面的时序图（开启 tcpdump 的 -S 选项来选择打印序号的绝对值）：

<div align="center"><image src="../doc/TCP连接的建立和关闭时序图.png"></image></div>

#### 三次握手过程

- 报文段 1 包含 SYN 标志，是一个同步报文段，即客户端 108 向 服务器 109 发起连接请求，该同步报文段包含一个 ISN 值为 535734930 的序号
- 报文段 2 也是同步报文段，表示 109 同意与 108 建立连接，同时发送自己的 ISN 值为 2159701207 的序号，并发送确认值 535734931 对第一个同步报文段进行确认，即第一个同步报文段的序号值加 1
  > 前面说过，序号值是用来标识 TCP 数据流中的每一个字节的，但同步报文段比较特殊，即使它没有携带任何应用程序数据，也要占用一个序号值
- 报文段 3 是 108 对 同步报文段 2 的确认

至此，TCP 三次握手完成，连接建立

#### 四次挥手过程

- 报文段 4 包含 FIN 标志，是一个结束报文段，即客户端 108 要求关闭连接，结束报文段和同步报文段一样，也要占用一个序号值
- 报文段 5 用来确认结束报文段 4
- 报文段 6 是服务器端发送给客户端的结束报文段
- 报文段 7 用来确认结束报文段 6

实际上，仅用于确认目的的确认报文段 5 是可以省略的，因为结束报文段 6 也携带了该确认信息，确认报文段 5 是否出现在连接断开的过程中，取决于 TCP 的延迟确认特性

上面的挥手过程中，客户端先发送结束报文段给服务器端，因此称客户端执行主动关闭，服务器执行被动关闭

### 2. 半关闭状态

TCP 连接是全双工的，所以它允许两个方向的数据传输被独立关闭

通信的一端主动关闭时，不能再发送数据给对端，但还可以继续接收来自对端的数据，直到对端也关闭连接另一端，TCP 连接的这种状态称为 **半关闭状态（half close）**，如下图：

<div align="center"><image src="../doc/TCP连接的半关闭状态.png"></image></div>

- 可以通过 read 系统调用返回 0 判断对方已经关闭连接
- socket API 中 通过 shutdown 函数 提供了对半关闭的支持

### 3. 连接超时

客户端连接服务器时，如果因为网络问题，服务器无法对连接做出应答时，客户端程序会怎么做？

一般，对于提供可靠服务的 TCP 来说，会先进行多次重连，如果重连仍然无效，则通知应用程序连接失败

下面，我们模拟一个繁忙的服务器环境，然后用客户端连接服务器：

先在服务器 109 上利用 `iptable` 命令过滤掉数据包，使其丢弃所有接收到的连接请求：

```
sudo iptables -F
sudo iptables -I INPUT -p tcp --syn -i eth0 -j DROP
```

下来，从客户端 108 执行 `telnet` 命令登录到服务器，并利用 `tcpdump` 抓取这个过程中的 TCP 报文段：

```
sudo tcpdump -n -i eth0 port 23
date; telnet 192.168.1.109; date  # 在 telnet 命令前后都执行 date 命令，以计算超时时间
Mon Jun 11 21:23:35 CST 2019
Try 192.168.1.109...
telnet: connect to address 192.168.1.109: Connection timed out
Mon Jun 11 21:24:38 CST 2019
```

从两次 `date` 命令看，客户端建立 TCP 连接的超时时间为 63 s

`tcpdump` 的输出如下：

```
1. 21:23:35.612136 IP 192.168.1.109.39385 > 192.168.1.108.telnet: Flags [S], seq 1355982096, length 0
2. 21:23:36.613146 IP 192.168.1.109.39385 > 192.168.1.108.telnet: Flags [S], seq 1355982096, length 0
3. 21:23:38.617279 IP 192.168.1.109.39385 > 192.168.1.108.telnet: Flags [S], seq 1355982096, length 0
4. 21:23:38.625140 IP 192.168.1.109.39385 > 192.168.1.108.telnet: Flags [S], seq 1355982096, length 0
5. 21:23:38.641344 IP 192.168.1.109.39385 > 192.168.1.108.telnet: Flags [S], seq 1355982096, length 0
6. 21:23:38.673331 IP 192.168.1.109.39385 > 192.168.1.108.telnet: Flags [S], seq 1355982096, length 0
```

- tcpdump 不适用 `-t` 选项可以输出时间戳，我们一共抓取到 6 个 TCP 报文段，它们都是同步报文段，并且具有相同的序号值，说明后面 5 个同步报文段都是超时重传报文段
- 这些 TCP 报文段被发送的时间间隔大致为 1s、2s、4s、8s、16s、32s，可见 TCP 模块一共执行了 5 次重连操作，这是由 `/proc/sys/net/ipv4/tcp_syn_retries` 内核变量所定义的，每次重连的超时时间都增加一倍，5 次重连均失败后，TCP 模块放弃连接并通知应用程序

## 四、TCP 状态转移

### 1. TCP 状态转移总图

TCP 连接的任意一端在任一时刻都处于某种状态，当前状态可通过 `netstat` 命令查看

下图是 TCP 连接从建立到关闭的整个过程中通信两端状态的变化，它描绘了所有的 TCP 状态以及可能的状态转换

<div align="center"><image src="../doc/TCP状态转移过程.png"></image></div>

> - 粗虚线表示典型的服务器端连接的状态转移；粗实线表示典型的客户端连接的状态转移
> - CLOSED 是一个假想的起始点，并不是实际的状态

下面对上图从服务端和客户端两个角度进行说明：

- 服务端

  - 服务器通过 `listen` 系统调用进入 `LISTEN` 状态，被动等待客户端连接
  - 当服务器监听到某个连接请求（收到同步报文段），就将该连接放入内核等待队列中，并向客户端发送带 SYN 标志的确认报文段，此时，该连接处于 `SYN_RCVD` 状态
  - 如果服务器成功接收到客户端发送回的确认报文段，则该连接转移到 `ESTABLISHED` 状态，ESTABLISHED 状态就是连接双方能够进行双向数据传输的状态
  - 当客户端主动关闭连接时（通过 `close` 或 `shutdown` 系统调用向服务器发送结束报文段），服务器通过返回确认报文段使连接进入 `CLOSE_WAIT` 状态，这个状态含义很明确，就是等待服务器应用程序关闭连接
  - 服务器检测到客户端关闭连接，也会立即给客户端发送一个结束报文段来关闭连接，这将使连接转移到 `LASK_ACK` 状态，以等待客户端对结束报文段的最后一次确认，一旦确认完成，连接将彻底关闭

- 客户端

  - 客户端通过 `connect` 系统调用主动与服务器建立连接，connect 系统调用给服务器发送一个同步报文段，使连接转移到 `SYN_SENT` 状态
    connect 系统调用可能因为以下两个原因失败返回：
    - 目标端口不存在（未被任何进程监听）或该端口仍被处于 `TIME_WAIT` 状态的连接占用，则服务器将给客户端发送一个复位报文段，connect 调用失败
    - 目标端口存在，但 connect 在超时时间内未收到服务器的确认报文段，connect 调用失败
  - connect 调用失败将使连接立即返回到初始的 `CLOSED` 状态；若客户端收到服务器的同步报文段和确认，则 connect 调用成功返回，连接转移至 `ESTABLISHED` 状态
  - 当客户端执行主动关闭时，会向服务器发送一个结束报文段，同时连接进入 `FIN_WAIT_1` 状态
    - 若此时客户端收到服务器专门用于确认目的地确认报文段，则连接转移至 `FIN_WAIT_2` 状态，当客户端处于 `FIN_WAIT_2` 状态时，服务器处于 `CLOSE_WAIT` 状态，这一对状态是可能发送半关闭的状态。如果此时服务器也关闭连接（发送结束报文段），则客户端将给予确认并进入 `TIME_WAIT` 状态，否则客户端将一直处于 `FIN_WAIT_2` 状态
      > 如果不是为了在半关闭状态下继续接收数据，连接长时间处于 `FIN_WAIT_2` 状态并无益处。连接停留在 `FIN_WAIT_2` 状态的情况可能发生在：客户端执行半关闭后，未等服务器关闭连接就强行退出了。此时客户端连接由内核接管，可称为孤儿连接。
      >
      > Linux 中定义了两个内核变量 `/proc/sys/net/ipv4/tcp_max_orphans` 和 `/proc/sys/net/ipv4/tcp_fin_timeout`，前者指定内核能接管的孤儿连接数目，后者指定孤儿连接在内核中生存的时间
    - 若此时客户端直接收到带确认信息的结束报文段（而不是先收到确认报文段，再收到结束报文段），客户端会从 FIN_WAIT_1 状态直接进入 `TIME_WAIT` 状态（不经过 FIN_WAIT_2）

对应于第四节中利用 tcpdump 观察 TCP 建立和关闭中的时序图，客户端和服务器的状态转移图如下：

<div align="center"><image src="../doc/TCP连接的建立和断开过程中状态转移变化.png"></image></div>

### 2. TIME_WAIT 状态

从上面的状态转移时序图来看，客户端连接在收到服务器的结束报文段 6 之后，并没有直接进入 CLOSED 状态，而是转移到了 `TIME_WAIT` 状态，在这个状态下，客户端连接要等待一段长为 **2MSL(Maximum Segment Life, 报文段最大生存时间)** 的时间，才能完全关闭。

> MSL 是 TCP 报文段在网络中的最大生存时间，标准文档的建议值为 2min

#### 为什么要有需要等待 2MSL 时间的 TIME_WAIT 状态？

TIME_WAIT 状态存在的原因有两点：

- 可靠地终止 TCP 连接

  以上面状态转移图为例，假设用于确认服务器结束报文段 6 的 TCP 报文段 7 丢失，那么服务器将重发结束报文段，因此客户端需要停留在某个状态以处理重复收到的结束报文段（即向服务器发送结束报文段）。否则，客户端将以复位报文段回应服务器，服务器则认为这是一个错误，因为它期望的是一个像 TCP 报文段 7 那样的确认报文段

- 保证让迟来的 TCP 报文段有足够的时间被识别并丢弃

  Linux 系统上，一个 TCP 端口不能被重复占用。当一个 TCP 连接处于 TIME_WAIT 状态时，我们将无法立即使用该连接占用的端口来建立一个新连接

  如果没有 TIME_WAIT 状态，那么新的应用程序将占用这个刚刚释放的 TCP 端口建立新连接，新连接就有可能接收到属于原来连接的 TCP 报文段（迟到的报文段）

  因为 TCP 报文段的最大生存时间是 MSL，所以坚持 2MSL 时间的 TIME_WAIT 状态能够确保网络上两个传输方向上尚未被接收到、迟到的 TCP 报文段都已经消失（被中转路由器丢弃）。因此，一个复用了原来连接端口的新连接可以在 2MSL 时间之后安全地建立，而绝对不会接收到属于原来连接的数据，**这就是 TIME_WAIT 状态要维持 2MSL 时间的原因**

#### 强制占用 TIME_WAIT 状态的连接的端口

有时候，我们希望避免 TIME_WAIT 状态，因为当服务器程序退出后，我们希望能够立即重启它，但由于处在 TIME_WAIT 状态的连接还占用着端口，程序将无法启动（直到 2MSL 超时时间结束）

我们使用 `nc` 程序模拟客户端以固定端口 1234 登录本机的 Web 服务，然后从终端以 ctrl+c 终止客户端程序，接着又立即重启 nc 程序，以相同的方式连接本机 Web 服务：

```
$ nc -p 12345 127.0.0.1 80
ctrl+c
$ nc -p 12345 127.0.0.1 80
nc: bind failed: Address already in use  # 连接失败，端口 12345 仍然被上个连接占用
```

这时，使用 `netstat -nat` 查看连接状态，可以看到端口 12345 处于 TIME_WAIT 状态：

```
$ netstat -nat
tcp   0   0  192.168.1.108:12345  192.168.1.108:80  TIME_WAIT
```

- 对客户端来说，因为客户端一般使用系统自动分配的临时端口号建立连接，所以不需要担心上述问题
- 但是对服务器而言，服务器程序总是使用同一个知名服务端口号，所以其关闭后不能立即重启
  可以使用 socket 选项 `SO_REUSEADDR` 来强制进程立即使用处于 TIME_WAIT 状态的连接占用的端口

## 五、复位报文段

某些特殊条件下，TCP 连接的一端会向另一端发送携带 RST 标志的报文段，即复位报文段，以通知对方关闭连接或重新建立连接

3 种情况下会产生复位报文段：

- 访问不存在的端口或访问被处于 TIME_WAIT 状态连接占用的端口

  当客户端程序访问一个不存在的端口时，目标主机将给它发送一个复位报文段

  考虑从本机(192.168.1.109)上执行 `telnet` 命令登录目标机器（192.168.1.108）上一个不存在的 54321 端口，并用 `tcpdump` 抓取该过程中两台主机交换的 TCP 报文段：

  ```
  $ sudo tcpdump -nt -i eth0 port 54321
  $ telnet 192.168.1.108 54321  # 连接被拒绝
  ```

  telnet 程序发出的连接被拒绝，因为这个端口不存在，tcpdump 的输出如下：

  ```
  1. IP 192.168.1.109.42001 > 192.168.1.108.54321: Flags [S], seq 21621375, win 14600, length 0
  2. IP 192.168.1.108.54321 > 192.168.1.109.42001: Flags [R.], seq 0, ack 21621376, win 0, length 0
  ```

  报文段 2 为目标主机 108 向 主机 109 发送的复位报文段（R 标志），复位报文段的接收通告窗口大小为 0，所以收到复位报文段的一端应该关闭连接或者重新连接，而不能回应这个复位报文段

  当客户端访问的端口被处于 TIME_WAIT 状态的连接占用时，客户端程序也将收到复位报文段

- 异常终止连接

  应用程序可以通过使用 socket 选项 SO_LINGER 发送复位报文段来主动异常终止一个连接，一旦发送了复位报文段，发送端所有排队等待发送的数据都将被丢弃

- 处理半打开连接

  当 TCP 连接的一方关闭或异常终止了连接，而另一方没有接收到结束报文段（如发送了网络故障）。这时就会出现连接一方认为连接已关闭而另一方认为连接仍存在的情况，处于这种状态的连接被称为半打开连接。如果客户端或服务器往处于半打开状态的连接写入数据时，则对方将回应一个复位报文段

  我们在服务端 109 上使用 `nc` 命令模拟一个服务器程序，使之监听 12345 端口，然后再客户端 108 上用 `telnet` 命令登录该端口，然后拔掉客户端网线，并在服务端终端服务器程序

  此时，客户端上运行的 telnet 程序维持着一个半打开连接，然后接上服务端的网线，并从客户端程序往半打开连接写入 1 字节数据

  运行 `tcpdump` 程序抓取整个过程中 telnet 客户端和 nc 服务器交换的 TCP 报文段：

  服务端运行：
  ```
  $ nc -l 12345
  ```

  客户端运行：
  ```
  $ sudo tcpdump -nt -i eth0 port 12345
  $ telnet 192.168.1.109 12345
  Connected to 192.168.1.109
  Escape character is '^]'.   # 此时断开服务端网线，并重启服务器
  a(回车)                     # 向半打开连接输入字符 a
  Connection closed by foreign host.
  ```

  telnet 的输出显示：连接被服务器关闭了。tcpdump 抓取到的 TCP 报文段内容如下：

  ```
  1. IP 192.168.1.108.55100 > 192.168.1.109.12345: Flags [S], seq 3093809365, length 0
  2. IP 192.168.1.109.12345 > 192.168.1.108.55100: Flags [S.], seq 1495337791, ack 3093809366, length 0
  3. IP 192.168.1.108.55100 > 192.168.1.109.12345: Flags [.], ack 1, length 0
  4. IP 192.168.1.108.55100 > 192.168.1.109.12345: Flags [P.], seq 1:4, ack 1, length 3
  5. IP 192.168.1.109.12345 > 192.168.1.108.55100: Flags [R], seq 1495337792, length 0
  ```

  - 前 3 个 TCP 报文段是正常建立 TCP 连接的 3 次握手的过程
  - 第 4 个 TCP 报文段由客户端发送给服务器，它携带了 3 字节的应用程序数据
  - 由于服务器程序已经终端，所以服务器对客户端发送的数据回应了一个复位报文段 5

## 六、TCP 交互数据流和成块数据流

TCP 报文段所携带的应用程序数据按照长度分为两种：交互数据和成块数据

- 交互数据仅包含很少的字节，使用交互数据的应用程序（或协议）对实时性要求高，比如 telnet、ssh 等
- 成块数据的长度则通常为 TCP 报文段允许的最大数据长度，使用成块数据的应用程序（或协议）对传输效率要求高，比如 ftp

### 1. TCP 交互数据流

使用 `telnet` 命令登录本机，然后在 shell 命令提示符后执行 ls 命令，同时用 `tcpdump` 抓取这一过程中 telnet 客户端和 telnet 服务器交换的 TCP 报文段

```
$ tcpdump -nt -i lo port 23
$ telnet 127.0.0.1  # 输入用户名密码 登录成功之后输入 ls
```

仅列出我们感兴趣的、执行 ls 命令产生的 tcpdump 输出：

```
1. IP 127.0.0.1.58130 > 127.0.0.1.23: Flags [P.], seq 1408334812:1408334813,ack 1415955507, win 613, length 1
2. IP 127.0.0.1.23 > 127.0.0.1.58130: Flags [P.], seq 1:2, ack 1, win 512, length 1
3. IP 127.0.0.1.58130 > 127.0.0.1.23: Flags [.], ack 2, win 613, length 0
4. IP 127.0.0.1.58130 > 127.0.0.1.23: Flags [P.], seq 1:2, ack 2, win 613, length 1
5. IP 127.0.0.1.23 > 127.0.0.1.58130: Flags [P.], seq 2:3, ack 2, win 512, length 1 
6. IP 127.0.0.1.58130 > 127.0.0.1.23: Flags [.], ack 3, win 613, length 0 
7. IP 127.0.0.1.58130 > 127.0.0.1.23: Flags [P.], seq 2:4, ack 3, win 613, length 2 
8. IP 127.0.0.1.23 > 127.0.0.1.58130: Flags [P.], seq 3:176, ack 4, win 512, length 173 
9. IP 127.0.0.1.58130 > 127.0.0.1.23: Flags [.], ack 176, win 630, length 0 
10. IP 127.0.0.1.23 > 127.0.0.1.58130: Flags [P.], seq 176:228, ack 4, win 512, length 52
11. IP 127.0.0.1.58130 > 127.0.0.1.23: Flags [.], ack 228, win 630, length 0 
```

- TCP 报文段 1 由客户端发送给服务器，它携带 1 个字节的应用程序数据，即字母 “1"
- TCP 报文段 2 是服务器对 TCP 报文段 1 的确认，同时回显字母 “1”
- TCP 报文段 3 是客户端对 TCP 报文段 2 的确认
- 第 4~6 个 TCP 报文段是针对字母 “s" 的上述过程
- TCP 报文段 7 传送的 2 字节数据分别是：客户端键入的回车符和流结束符( EOP,本例中是 0x00)
- TCP 报文段 8 携带服务器返回的客户查询的目录的内容( ls 命令的输出)，包括该目录下文件的文件名及其显示控制参数
- TCP 报文段 9 是客户端对 TCP 报文段 8 的确认
- TCP 报文段 10 携带的也是服务器返回给客户端的数据，包括一个回车符、一个换行符、客户端登录用户的 PSI 环境变量
- TCP 报文段 11 是客户端对 TCP 报文段 10 的确认

#### 延迟确认

上述过程中，客户端针对服务器返回的数据所发送的确认报文段( TCP 报文段 6、9和11 )都不携带任何应用程序数据(长度为 0 ),而服务器每次发送的确认报文段(TCP报文段 2、5、8和10 )都包含它需要发送的应用程序数据。

服务器的这种处理方式称为 **延迟确认**，即它不马上确认上次收到的数据，而是在一段延迟时间后看本端是否有数据需要发送，如果有，则和确认信息一起发出，因为服务器对客户请求处理得很快，所以它发送确认报文段的时候总是有数据一起发送。 廷迟确认可以减少发送TCP报文段的数量、而由于用户的输入速度明显慢于客户端程序的处理速度，所以客户端的确认报文段总是不携带任何应用程序数据。

前面曾提到，在TCP连接的建立和断开过程中，也可能发生延迟确认。

#### Nagle 算法

上例是在本地回路运行的结果，在局城网中也能得到基本相同的结果，但在广城网就未必如此了。广城网上的交互数据流可能经受很大的延迟，并且，携带交互数据的微小 TCP 报文段数量一般很多(一个按键输人就导致一个 TCP 报文段)，这些因素都可能导致拥塞发生。

解决该问题的一一个简单有效的方法是使用 **Nagle算法**

Nagle 算法要求一个 TCP 连接的通信双方在任意时刻都最多只能发送一个未被确认的 TCP 报文段，在该 TCP 报文段的确认到达之前不能发送其他 TCP 报文段。另一方面，发送方在等待确认的同时收集本端需要发送的微量数据，并在确认到来时以一一个 TCP 报文段将它们全部发出。这样就极大地减少了网络上的微小 TCP 报文段的数量。

该算法的另一个优点在于其自适应性:确认到达得越快，数据也就发送得越快。

3.7 TCP成块数据流

下面考虑用FTP协议传输一个大文件。在emest-lipiop上启动一个 vstpd服务器程序(升级的、安全版的ftp服务器程序)，并执行ftp命令登录该服务器上，然后在ftp命令提示符后输人get命令，从服务器下载一个几百兆的大文件.同时用tpdump抓取这一个过程中fp客户端和vsftpd 服务器交换的TCP报文段。具体操作过程如下:

      $ sudo tepdump -nt -i etho port 20  ，vsftpd服务器程序使用端口号20

### 2. TCP 成块数据流

## 七、带外数据

## 八、拥塞控制

