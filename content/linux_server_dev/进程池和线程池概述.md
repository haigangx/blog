# 进程池和线程池

普通通过动态创建子进程(或子线程)实现并发服务器的缺点：

- 动态创建进程(或线程)比较耗费事件，将导致较慢的客户响应
- 动态创建的子进程(子线程)通常只用来为一个客户服务，这将导致系统上产生大量的细微进程(或线程)。进程(或线程)间的切换将消耗大量CPU时间
- 动态创建的子进程是当前进程的完整映像。当前进程必须谨慎地管理其分配的文件描述符和堆内存等系统资源，否则子进程可能复制这些资源，从而使系统的可用资源急剧下降，进而影响服务器的性能

使用进程池和线程池可以避免上述缺点

## 进程池和线程池概述

进程池中所有子进程运行着相同的代码，并具有相同的属性，比如优先级、PGID等。因为进程池在服务器启动之初就创建好了，所以每个子进程都相对干净：即它们没有打开不必要的文件描述符(从父进程继承而来)，也不会错误地使用大块的堆内存(从父进程复制得到)

进程池的一般模型：

![进程池模型](doc/process_pool_thread_pool_1.png)

进程池模型分为两部分：

- 主进程选择哪个子进程来为新任务服务，有两种方式：
    - 主进程使用某种算法来主动选择子进程。最简单、最常用的算法是随机算法和Round Robin(轮流选取)算法，但更优秀更智能的算法将使任务在各个工作进程中更均匀地分配，从而减轻服务器的整体压力
    - 主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上。当有新的任务到来时，主进程将任务添加到工作队列中。这将唤醒正在等待任务的子进程，不过只有一个子进程将获得新任务的接管权，它可以从工作队列中取处任务并执行之，而其他子进程将继续睡眠在工作队列上
- 选择好子进程后，主进程还需要使用某种通知机制来告诉目标子进程有新任务需要处理，并传递必要的数据
    - 最简单的办法是：在父进程和子进程之间预先建立好一条管道，然后通过该管道来实现所有的进程间通信，在父线程和子线程之间传递数据更加简单，因为我们可以把这些数据定义为全局的，那么他们本身就是被所有线程共享的


## 处理多客户

由之前学习的两类并发模式：
- 半同步/半反应堆：主线程接收新的连接以得到连接socket，然后它将该socket传递给子进程管理，主线程管理监听socket和连接socket
- 半同步/半异步模式：主线程管理所有监听socket，各个子进程分别管理属于自己的连接socket

设计进程池时要考虑：
- 一个客户连接上的所有任务是否始终由一个子进程来处理。如果客户任务是无状态的，那么可以考虑使用不同的子进程来为该客户的不同请求服务，如下图：

![多个子进程处理同一个客户连接上的不同任务](doc/process_pool_thread_pool_2.png)

- 但如果客户任务是存在上下文关系，最好一直用同一个子进程来为之服务，否则实现起来将比较麻烦，因为不得不在各子进程之间传递上下文数据
