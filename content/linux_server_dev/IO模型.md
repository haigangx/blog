# IO模型

- 同步I/O：从理论上讲，阻塞I/O、I/O复用和信号驱动I/O都是同步I/O模型。因为这三种I/O模型中，I/O的读写操作都是在I/O事件发生之后，由应用程序来完成的
    
  - 阻塞I/O：
  
    阻塞的文件描述符为阻塞I/O，socket创建时默认阻塞

    针对阻塞I/O所执行的系统调用可能会因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。例如：客户端通过connect向服务器发起连接时，connect将首先发送同步报文段给服务器，然后等待服务器返回确认报文段。如果服务器的确认报文段没有立即到达客户端，则connect调用将被挂起，直到客户端收到确认报文段并唤醒connect调用。socket的基础API中，可能被阻塞的系统调用包括accept、send、recv和connect

  - 非阻塞I/O：

    非阻塞的文件描述符为非阻塞I/O，通过socket系统调用的第二个参数设为SOCK_NONBLOCK或者通过fcntl系统调用的F_SETFL命令来设置非阻塞

    针对非阻塞I/O所执行的系统调用则总是立即返回，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回-1，和出错的情况一样。此时我们必须根据errno来区分这两种情况。对accpet、send和recv而言，事件未发生时errno通常被设置成EAGAIN（“再来一次”）或者EWOULDBLOCK（“期望阻塞”）；对connect而言，errno则被设置成EINPROGRESS（“在处理中”）

    显然，我们只有在事件已经发生的情况下操作非阻塞I/O（读、写等），才能提高程序的效率。因此，非阻塞I/O通常要和其他I/O通知机制一起使用，比如I/O复用和SIGIO信号

    - 非阻塞I/O + I/O复用：
    
        I/O复用指应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序。Linux上常用的I/O复用函数是select、poll、和epoll_wait。I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力

    - 非阻塞I/O + SIGIO信号：

        SIGIO信号可以报告I/O事件。使用fcntl函数为一个目标文件描述符制定宿主进程，被制定的宿主进程将捕获到SIGIO信号。这样，当目标文件描述符上有事件发生时，SIGIO信号的信号处理函数将被触发，我们就可以在该信号处理函数中对目标文件描述符执行非阻塞I/O操作了

- 异步I/O：

    真正的异步I/O，用户可以直接对I/O执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及I/O操作完成之后内核通知应用程序的方式。异步I/O的读写操作总是立即返回，而不论I/O是否是阻塞的，因为真正的读写操作已经由内核接管。可以这样理解：

    > 同步I/O模型向应用程序通知I/O就绪事件，应用程序根据用户编写代码执行I/O操作（将数据从内核缓冲区读入用户缓冲区，或将数据从用户缓冲区写入内核缓冲区），而异步I/O模型则由内核来执行I/O操作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台完成的”）

    Linux中，aio.h头文件中定义的函数提供了对异步I/O的支持

下表展示了几种I/O模型的差异对比：

| I/O模型 | 读写操作和阻塞阶段 |
| --- | --- |
| 阻塞I/O | 程序阻塞于读写函数 |
| I/O复用 | 程序阻塞于I/O复用系统调用，但可同时监听多个I/O事件，对I/O本身的读写操作时非阻塞的 |
| SIGIO信号 | 信号触发读写就绪事件，用户程序执行读写操作，程序没有阻塞阶段 |
| 异步I/O | 内核执行读写操作并触发读写完成事件，程序没有阻塞阶段 |

