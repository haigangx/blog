# 高性能定时器

## 时间轮

基于排序链表的定时器存在一个问题：添加定时器的效率偏低。采用事件轮将解决这个问题

TODO: 时间轮示意图

上图所示的时间轮内，实线指针指向轮子上的一个槽(slot)，它以恒定的速度顺时针转动，每转动一步就指向下一个槽(虚线指针指向的槽)，每次转动称为一个滴答(tick)。一个滴答的时间称为时间轮的槽间隔si(slot interval)，它实际上就是心博时间。该时间轮共有N个槽，因此它运转一周的时间是N*si。每个槽指向一条定时器链表，每条链表上的定时器具有相同的特征：它们的定时时间相差N*si的整数倍。时间轮正是利用这个关系将定时器散列到不同的链表中。假如现在指针指向槽cs，我们要添加一个定时时间为ti的定时器，则该定时器将被插入槽ts(time slot)对应的链表中:ts = (cs + (ti/si)) % N

基于排序链表的定时器使用唯一的一条链表来管理所有定时器，所以插入操作的效率随着定时器数目的增多而降低。而时间轮使用哈希表的思想，将定时器散列到不同的链表上。这样每条链表上的定时器数目都将明显少于原来的排序链表上的定时器数目，插入操作的效率基本不受定时器数目的影响

对时间轮而言，要提高定时精度，就要使si值足够小；要提高执行效率，则要求N值足够大

上图描述的是一种简单的时间轮，因为只有一个轮子，而复杂的时间轮可能有多个轮子，不同的轮子拥有不同的粒度。相邻的两个轮子，精度高的转一圈，精度低的仅往前移动一槽，就像水表一样

时间轮中添加一个定时器的时间复杂度为O(1)，删除一个定时器的事件复杂度也是O(1)，执行一个定时器的时间复杂度是O(n)，但实际的执行效率要比O(n)好


## 时间堆

定时器的两种设计思路：

- 以固定的频率调用心博函数tick，并在其中依次检测到期的定时器，然后执行到期定时器上的回调函数
- 将所有定时器中超时时间最小的定时器的超时值作为心博间隔，这样，当心博函数tick被调用时，超时时间最小的定时器必然到期，就可以在tick函数中处理该定时器，然后再次从剩余定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心博间隔。

时间堆使用第二种设计思路，采用最小堆为定时器的底层数据结构，最小堆是指每个节点值都小于或等于其子节点的值的完全二叉树，可以使���数组来存储该最小堆

对时间堆而言，添加一个定时器的时间复杂度为O(lgn)，删除一个定时器的时间复杂度为O(1)，执行一个定时器的时间复杂度是O(1)
