# 条款30：透彻了解inlining的里里外外

- inline只是对编译器的一个申请，不是强制命令，这项申请可以隐喻提出，也可以明确提出，隐喻方式是将函数定义于class定义式中，
  明确声明是在其定义式前加关键字inline

- inline的代价：
  inline函数背后的整体观念是，将"对此函数的每一个调用"都以函数本体替换之，这样做可能增加你的目标码(object code)大小。
  在一台内存有限的机器上，过度热衷inlining会造成程序体积太大，即使拥有虚内存，inline造成的代码膨胀亦会导致额外的换页行为，
  降低指令高速缓存装置的命中率
  
  换个角度，如果inline函数的本体很小，编译器针对"函数本体"所产出的码可能比针对"函数调用"所产出的码更小。
  果真如此，将函数inling确实可能导致较小的目标码和较高的指令高速缓存装置命中率

- inline函数通常一定被置于头文件中，因为大多数建置环境(build environments)在编译过程中进行inlining，
  而为了将一个“函数调用”替换为"被调用函数的本体"，编译器必须知道那个函数的样子，C++的Inlining在编译期进行

- 将一个template声明为inline，则由该tempalte具现出现的所有函数都是inlined，如果你无法理由要求你写的template所具现出现的
  每个函数都是inlined的，应该避免将这个template声明为inline

- inline是个申请，编译器可以加以忽略：编译器拒绝将太过复杂(带有循环或递归)的函数inlining，也不会对virtual函数的调用inlining，
  因为virtual意味着"等待，直到运行期才确定调用哪个函数"，而inline意味着"执行前，先将调用动作替换为被调用函数的本体"，两者矛盾

- 有时候虽然编译器有意愿inlining某个函数，还是可能为该函数生成一个函数本体，例如：如果程序要取某个inline函数的地址，
  编译器通常必须为此函数生成一个outlined函数本体，编译器通常不对"通过函数指针而进行的调用"实施inlining，
  这意味对inline函数的调用有可能被inlined，也可能不被inlined，取决于该调用的实施方式：
  
  ```
  inline void f( ) { ... }
  void ( *pf )() = f;     //pf执行f
  ...
  f();        //此调用将被inlined
  pf();       //通过函数指针调用，此调用不被inlined
  ```

- 不要试图将构造函数和析构函数inlining

  一个空的构造函数看起来是inlining的绝佳候选人，因为它看起来根本不含任何代码，但是事实并非如此
  
  C++对于"对象被创建和被销毁时发生什么事情"做了各式各样的保证：当你使用new，动态创建的对象被其构造函数自动初始化，
  当你使用delete，对应的析构函数会被调用，当你创建一个对象，其每一个base class及每一个成员变量都会被自动构造；
  当你销毁一个对象，反向程序的析构行为亦会自动发生。如果有个异常在对象构造期间被抛出，该对象已构造好的那一部分会被自动销毁。
  而保证这些事情发生的代码有时候就放在构造函数和析构函数中，所以表面上看起来为空的Derived构造函数所产生的代码并且为空
  
  相同的理由也适用于Base构造函数，如果它被inlined，所有替换"Base构造函数调用"而插入的代码也都会被插入
  到"Derived构造函数调用"内(因为Derived构造函数调用了Base构造函数)

- inline函数无法随着程序库的升级而升级：如果f是程序库内的一个inline函数，客户将"f函数本体"编进其程序中，一旦程序库设计者决定改变f，
  所有用到f的客户端程序都必须重新编译，然后如果f是non-inline函数，一旦它有任何修改，客户端只需重新连接就好，远比重新编译的负担少很多

- 从纯粹使用的角度出发：大部分调试器面对inline函数都束手无策，毕竟你无法在一个并不存在的函数内设置断点

任何时候在决定哪些函数被声明为inline而哪些函数不该时，要考虑到上面的9条考虑
