# Knuth-Morris-Pratt子字符串查找算法

<!-- TOC -->

- [举例说明KMP算法主要过程：](#举例说明kmp算法主要过程)
- [如何得到部分匹配表？](#如何得到部分匹配表)
    - [前缀和后缀](#前缀和后缀)
    - [部分匹配值](#部分匹配值)
    - [如何理解部分匹配值？](#如何理解部分匹配值)
- [代码实现](#代码实现)

<!-- /TOC -->

KMP算法的基本思想是当出现不匹配时，就能知晓一部分文本的内容(因为在匹配失败之前它们已经和模式的一部分相匹配)，我们可以利用这些信息避免将指针回退到所有这些已知的字符之前，这一切都基于[暴力法子字符串查找](子字符串查找-暴力子字符串查找算法.md)的第二种实现展开。

## 举例说明KMP算法主要过程：

以在文本字符串"BBC ABCDAB ABCDABCDABDE"中查找模式子串"ABCDABD"为例：

![查找文本字符串和模式字符串比较起点](../doc/kmp_1.png)

首先，文本字符串的第一个字符与模式字符串的第一个字符进行比较，因为B与A不匹配，所以文本字符串后移一位，直到与模式字符串首字母相匹配

![找到起始点](../doc/kmp_3.png)

找到文本字符串中和模式字符串首字符相同的字符后，接着比较文本字符和模式字符串后面的字符

![遇到不匹配](../doc/kmp_5.png)

等匹配到了D，发现不对，这里如果使用暴力法，则直接将模式后移一位，重新匹配。KMP算法的想法是，设法利用这个已知信息，不要把"搜索位置"移回已经比较过的位置，这样就提高了效率

怎么做到这一点呢？KMP算法的做法是针对模式词，算出一张《部分匹配表》PMT(Partial Match Table)。这张表如何产生后面再介绍，这里我们直接拿来用

《部分匹配表如下图所示》：

![部分匹配表](../doc/kmp_8.png)

部分匹配表如何使用呢？根据上面的步骤，我们已知空格与D产生不匹配，前面六个字符"ABCDAB"是匹配的。查表可知，最后一个匹配字符B对应的"部分匹配值"为2，因此按照如下公式算出模式字符串向后移动的位数：

```
移动位数 = 已匹配的字符数 - 对应的部分匹配值
```

因为6-2=4，所以将模式字符串向后移动4位

![模式字符串移动后](../doc/kmp_10.png)

因为空格与C不匹配，模式字符串还要继续往后移。这时，已匹配的字符数为2（"AB"），对应的"部分匹配值"为0。所以移动位数为2-0，结果为2，于是将模式词向后移动2位

![继续移动](../doc/kmp_11.png)

因为空格与A不匹配，继续后移一位，逐位比较，直到发现C与D不匹配

![继续后移](../doc/kmp_12.png)

于是，移动位数 = 6 - 2，继续将模式词向后移动4位

![继续后移](../doc/kmp_13.png)

逐位比较，直到模式词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索(即找出全部匹配)，移动位数= 7 - 0，再将搜索词向后移动7位，这里就不重复了

所以，KMP算法的重点是算出部分匹配表，然后按部就班完成搜索即可。

## 如何得到部分匹配表？

### 前缀和后缀

首先，我们需要了解两个概念： **前缀** 和 **后缀** ：

- 前缀是指除了最后一个字符之外，一个字符串的全部头部组合
- 后缀是指除了第一个字符之外，一个字符串的全部尾部组合

以字符串 "bread" 为例：

它的前缀有：b, br, bre, brea

它的后缀有：read, ead, ad, d

### 部分匹配值

**部分匹配值就是前缀和后缀的最长的共有元素的长度**。以 "ABCDABD" 为例：

－　"A"的前缀和后缀都为空集，共有元素的长度为0
－　"AB"的前缀为[A]，后缀为[B]，共有元素的长度为0
－　"ABC"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0
－　"ABCD"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0
－　"ABCDA"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1
－　"ABCDAB"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为2
－　"ABCDABD"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0

所以其构成的部分匹配表如下：

![部分匹配表](../doc/kmp_8.png)

### 如何理解部分匹配值？

![理解部分匹配值](../doc/kmp_12.png)

"部分匹配"的实质是：有时候，字符串头部和尾部会有重复。比如："ABCDAB" 之中有两个 "AB"，那么它的"部分匹配值"就是2("AB"的长度)。搜索词移动的时候，第一个 "AB" 向后移动4位(字符串长度-部分匹配值),就可以来到第二个 "AB" 的位置。


## 代码实现

参考：

- [字符串匹配的KMP算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)
- [知乎：如何更好的理解和掌握KMP算法？](https://www.zhihu.com/question/21923021)
- [数据结构拾遗：子字符串匹配常用算法总结](https://cloud.tencent.com/developer/article/1483279)
- 《算法》第四版