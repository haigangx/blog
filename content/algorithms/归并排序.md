# 归并排序

## 一、经典归并排序

归并排序就是将要排序的数组分成两部分，每一部分都排好序，再将这两部分归并为一个数组，每一部分的排序又采用归并排序。

归并排序按照空间的使用上来分主要分为两种：普通归并和原地归并。按照归并的方向可以分为自顶向下归并和自底向上归并。

### 1. merge函数

归并排序最主要的一个函数就是merge，函数接口如下：

```
void merge(int data[], int start, int mid, int end);
```

这个函数负责将data数组中start-mid子数组和mid-end子数组进行原地归并，这个函数的前提条件是两个子数组都已经排好序。下面是这个函数的具体实现代码：

```
//归并两个排好序的数组
void merge(vector<int>& nums, int l, int m, int h)
{
    int i = l, j = m + 1;
    vector<int> aux(nums.begin(), nums.end());
    for (int k = l; k <= h; k++)
    {
        //i>=mid说明前半部分先被合并完，直接将后半部分剩余的元素接到data后面
        if (i > m)
            nums[k] = aux[j++];
        //i>=mid说明后半部分先被合并完，直接将前半部分剩余的元素接到data后面
        else if (j > h)
            nums[k] = aux[i++];
        //两者中选择较小的放到data中
        else if (aux[i] < aux[j])
            nums[k] = aux[i++];
        else
            nums[k] = aux[j++];

    }
}
```

归并排序最主要的函数就是merge函数，所以保证将merge函数写正确是非常重要的，写归并排序的时候可以先写一个merge函数，然后模拟几个环境测试一下，测试没有问题之后再进行下一步，否则如果一次性将整个归并算法全部写出，出现问题之后，因为递归层数比较多，找起来很麻烦。写好了merge函数，不管是自顶向下还是自底向上归并都只是对merge函数不同方式的调用而已。

<div align="center"><img src="img/merge_sort.gif" /></div>

### 2. 归并排序的两种方向：

为了直观的理解自顶而下和自底向上，我放了一张图。

<div align="center"><img src="img/merge_sort1.png"></img></div>

#### 2.1 自顶而下归并

自顶而下顾名思义：就是从最上面到最下面了，从这幅图来看，最上面就是a[0...15]，就是整个数组了。而最下面就是每一个元素了。所以自顶而下归并就是先从数组的整体出发，将数组全部元素看做一个整体，将这个整体分成两部分，并且假设每一部分都已经排好序了，所以只需要将这两部分直接归并，但是为了保证这两个部分都已经排好序，我们又需要为每一部分使用归并排序排序，在对图中第二层的每个子数组调用归并排序时，又会将图中第二层的数组分解为第三层，然后分别调用归并排序，经过这样几轮递归后，直到每个子数组都只剩下一个元素递归才开始回溯。回溯完成，排序也就完成了。这就是自顶而下。

##### 自顶向下代码实现：

因为自顶向下归并要使用递归，传递参数时要向下一层递归传递一些信息，为了保证接口的统一性，所以特别增加了内部函数merge_sort1_core来完成排序的主要工作。

```
void merge_sort1(vector<int>& nums)
{
    merge_sort1_core(nums, 0, nums.size() - 1);
}
void merge_sort1_core(vector<int>& nums, int l, int h)
{
    if (h <= l)
        return;
    int m = (l + h) / 2;
    merge_sort1_core(nums, l, m);
    merge_sort1_core(nums, m + 1, h);
    merge(nums, l, m, h);
}
```

<div align="center"><img src="img/merge_sort2.png"></img></div>

#### 2.2 自底向上归并


自底向上：与自顶向下刚好相反，先从子数组依赖树的最低端出发，保证在为一个数组排序时，它的两个部分都已经被排好序，（自顶而下是假设已经排好序，两个不一样）

##### 自底向上代码实现

```
void merge_sort2(vector<int>& nums)
{
    int size = nums.size();

    for (int sz = 1; sz < size; sz += sz)
    {
        for (int lo = 0; lo < size - sz; lo += sz + sz)
        {
            int end = lo + sz + sz - 1 < size - 1 ? lo + sz + sz - 1 : size - 1;
            merge(nums, lo, lo + sz - 1, end);
        }
    }
}
```

<div align="center"><img src="img/merge_sort3.png"></img></div>

## 二、性能分析

- 时间复杂度：NlogN 
- 空间复杂度：N
- 稳定性：稳定
