### 高位优先的字符串排序

从左到右检查字符串中的字符，这种方法一般称为 *高位优先(MSD)* 的字符串排序，高位优先的字符串排序的优先在于：它不一定需要检查所有的输入就能够完成排序


要实现一个通用的字符串排序算法（字符串的长度不一定相同），应该考虑从左向右遍历所有字符，即高位优先的字符串排序，最终实现字符串的字典序排序。

实现这种思想可以采用递归算法：首先用键索引计数法将所有字符串按照首字母排序，然后（递归地）再将每个首字母所对应的子数组排序（忽略首字母，因为每一类中的所有字符串的首字母都是相同的），还可以再子数组较小时使用插入排序进行优化

高位优先字符串排序的最坏情况是所有的字符串键都相同，这时将递归对所有字符串每个字符进行比较

![高位优先字符串排序过程](img/string_msd_sort1.png)

思想讲起来总是很简单，不过当中的一些细节却是我们需要注意的。一个显而易见的问题就是怎么处理结尾字符的问题，因为MSD运行字符的长度不通，那么总会有字符串先结束，这时我们就需要对这些字符串进行处理。如果我们每个字符都去判断显然会很麻烦，因此我们选择一种巧妙的方式使用一个CharAt(string, int)函数来返回字``符串对应下标的字符，当对应下标不存在的时候我们返回-1

```
/* 转换函数：返回字符串中对应索引的字符
 * 参数：s：想要进行转换的字符串 i：字符索引
 * 返回值：对应索引的字符，若超出字符串长度返回-1
 */
char CharAt(string s, int i)
{
    if (i < s.length())
        return s[i];
    else
        return -1;
}
```

这样我们就可以把字符串结尾的情况同其余情况一起处理，同时保证了已结尾的字符串会在未结尾的字符串之前

```
void MSD(string *a, string*Aux, int *Count, int lo, int hi, int d)
{
    int const M = 3, R = 256;

    //小的子数组进行插入排序，与快速排序相同
    if (hi <= lo+M)
    {
        InsertionSort(a, lo, hi, d);
        return ;
    }

    //初始化索引数组
    for (int i = 0; i < R+2; i++)
    {
        Count[i] = 0;
    }

    //统计频数
    //特别说明：Count[0]:无用，Count[1]:长度为d的字符串个数
    for (int i = lo; i <= hi; i++)
    {
        Count[CharAt(a[i], d)+2]++;
    }

    //转换频数为索引
    for (int i = 0; i < R+1; i++)
    {
        Count[i+1] += Count[i];
    }

    //数组分类
    for (int i = lo; i < hi; i++)
    {
        Aux[Count[CharAt(a[i], d)+1]++] = a[i];
    }

    //回写
    for (int i = lo; i <= hi; i++)
    {
        a[i] = Aux[i-lo];
    }

    //递归排序
    //特别说明：Count[0]:长度为d的字符串索引的终止坐标
    for (int i = 0; i < R; i++)
    {
        MSG(a, Aux, Count, lo+Count[i], lo+Count[i+1]-1, d+1);
    }
}

/* 高位优先排序：将目标字符串进行高位优先排序
 * 参数：a:想要进行高位优先排序的数组 N:数组中元素的个数
 * 返回值：无
 */
void MSG(string *a, int N)
{
    int R = 256;
    int *Count = new int[R+2];
    string *Aux = new string[N];

    MSG(a, Aux, Count, 0, N-1, 0);

    Aux = NULL;
    delete Aux;
    Aux = NULL;
    delete Count;
    Count = NULL;
}
```

### 优化

#### 元素较少时使用插入排序

上面的两种字符串排序方法，不管是低位优先还是高位优先，都采用键索引计数法排序，这种排序方法每次排序时都需要开辟固定大小的空间，以空间换取时间。所以在要排序的字符串数量较多的情况下表现很好，但是在排序的字符串较少时，会出现浪费大量空间的情况，所以在子数组中字符串较少的情况下代用插入排序提高效率

#### 最坏情况

高位优先字符串排序在处理含有大量等值键的子数组时会比较慢，如果相同的子字符串出现的过多，切换排序方法条件将不会出现，那么递归方法就会检查所有相同键中的每一个字符。另外，键索引计数法无法有效判断字符串中的字符是否全部相同：它不仅需要检查每个字符和移动每个字符串，还需要初始化所有的频率统计并将它们转换为索引等。

因此，高位优先的字符串排序的最坏情况就是所有的键均相同。大量含有相同前缀的键也会产生同样的问题
