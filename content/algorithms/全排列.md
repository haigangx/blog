# 全排列生成算法

[全排列生成算法](https://zh.wikipedia.org/wiki/%E5%85%A8%E6%8E%92%E5%88%97%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95)
即将给定序列中所有可能的全排列无重复无遗漏地枚举出来，此处全排列地定义是：从n个元素中取出m个元素进行排列，当n=m时这个排列被称为全排列，
生成全排列地方法有：回溯法、字典序法、邻位对换法、循环移位法、递增进位制法、递减进位制法等

用C++写一个函数, 如 Foo(const char \*str), 打印出 str 的全排列,
如 abc 的全排列: abc, acb, bca, dac, cab, cba


## 一、回溯法

### 1. 全排列的递归实现

为方便起见，用123来示例下。123的全排列有123、132、213、231、312、321这六种。首先考虑213和321这二个数是如何得出的。显然这二个都是123中的1与后面两数交换得到的。然后可以将123的第二个数和每三个数交换得到132。同理可以根据213和321来得231和312。因此可以知道——全排列就是从第一个数字起每个数分别与它后面的数字交换。找到这个规律后，递归的代码就很容易写出来了：

***【注】：将上面描述的过程画成图就可以清晰的看出来递归的过程。***

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODA3MTAyODQ0NDU5?x-oss-process=image/format,png)

```
#include<iostream>  
using namespace std;  
#include<assert.h>  
    
void Permutation(char* pStr, char* pBegin)  
{  
    assert(pStr && pBegin);  
    
    if(*pBegin == ‘\0’)  
        printf(”%s\n”,pStr);  
    else  
    {  
        for(char* pCh = pBegin; *pCh != ‘\0’; pCh++)  
        {  
            swap(*pBegin,*pCh);  
            Permutation(pStr, pBegin+1);  
            swap(*pBegin,*pCh);  
        }  
    }  
}  
```

#### 另外一种写法：

```
//k表示当前选取到第几个数，m表示共有多少个数  
void Permutation(char* pStr,int k,int m)  
{  
    assert(pStr);  
    
    if(k == m)  
    {  
        static int num = 1;  //局部静态变量，用来统计全排列的个数  
        printf(”第%d个排列\t%s\n”,num++,pStr);  
    }  
    else  
    {  
        for(int i = k; i <= m; i++)  
        {  
            swap(*(pStr+k),*(pStr+i));  
            Permutation(pStr, k + 1 , m);  
            swap(*(pStr+k),*(pStr+i));  
        }  
    }  
}   
```
如果字符串中有重复字符的话，上面的那个方法肯定不会符合要求的，因此现在要想办法来去掉重复的数列。

### 2. 去掉重复的全排列的递归实现

由于全排列就是从第一个数字起每个数分别与它后面的数字交换。我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这二个数就不交换了。如122，第一个数与后面交换得212、221。然后122中第二数就不用与第三个数交换了，但对212，它第二个数与第三个数是不相同的，交换之后得到221。与由122中第一个数与第三个数交换所得的221重复了。所以这个方法不行。

换种思维，对122，第一个数1与第二个数2交换得到212，然后考虑第一个数1与第三个数2交换，此时由于第三个数等于第二个数，所以第一个数不再与第三个数交换。再考虑212，它的第二个数与第三个数交换可以得到解决221。此时全排列生成完毕。

***【注】：将上面描述的过程画成图就可以清晰的看出来递归的过程。***

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODA3MTAyOTA5NzAw?x-oss-process=image/format,png)

这样我们也得到了在全排列中去掉重复的规则——去重的全排列就是从第一个数字起每个数分别与它后面非重复出现的数字交换。下面给出完整代码：

```
#include<iostream>  
using namespace std;  
#include<assert.h>  
    
//在[nBegin,nEnd)区间中是否有字符与下标为pEnd的字符相等  
bool IsSwap(char* pBegin , char* pEnd)  
{  
    char *p;  
    for(p = pBegin ; p < pEnd ; p++)  
    {  
        if(*p == *pEnd)  
            return false;  
    }  
    return true;  
}  
void Permutation(char* pStr , char *pBegin)  
{  
    assert(pStr);  
    
    if(*pBegin == ‘\0’)  
    {  
        static int num = 1;  //局部静态变量，用来统计全排列的个数  
        printf(”第%d个排列\t%s\n”,num++,pStr);  
    }  
    else  
    {  
        for(char *pCh = pBegin; *pCh != ‘\0’; pCh++)   //第pBegin个数分别与它后面的数字交换就能得到新的排列     
        {  
            if(IsSwap(pBegin , pCh))  
            {  
                swap(*pBegin , *pCh);  
                Permutation(pStr , pBegin + 1);  
                swap(*pBegin , *pCh);  
            }  
        }  
    }  
} 
```

OK，到现在我们已经能熟练写出递归的方法了，并且考虑了字符串中的重复数据可能引发的重复数列问题。那么如何使用非递归的方法来得到全排列了？

### 3. 全排列的非递归实现

***【注】：这种方法的前提是输入的字符串是预先由小到大排好序的***

要考虑全排列的非递归实现，先来考虑如何计算字符串的下一个排列。如”1234”的下一个排列就是”1243”。只要对字符串反复求出下一个排列，全排列的也就迎刃而解了。

如何计算字符串的下一个排列了？来考虑”926520”这个字符串，我们从后向前找第一双相邻的递增数字，”20”、”52”都是非递增的，”26 “即满足要求，称前一个数字2为替换数，替换数的下标称为替换点，再从后面找一个比替换数大的最小数（这个数必然存在），(【这块没太读懂，按我自己的理解应该是，再从后往前找到第一个比替换数大的数】)，0、2都不行，5可以，将5和2交换得到”956220”，然后再将替换点后的字符串”6220”颠倒即得到”950226”。

对于像“4321”这种已经是最“大”的排列，采用STL中的处理方法，将字符串整个颠倒得到最“小”的排列”1234”并返回false。

***【注】：将上面描述的过程画成图就可以清晰的看出来递归的过程。***

[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RlCtDeRx-1574778815228)(http://img.blog.csdn.net/20170807102926688?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2l0aHViXzM2MTg2NDg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)]

这样，只要一个循环再加上计算字符串下一个排列的函数就可以轻松的实现非递归的全排列算法。按上面思路并参考STL中的实现源码，不难写成一份质量较高的代码。值得注意的是在循环前要对字符串排序下，可以自己写快速排序的代码（请参阅《白话经典算法之六 快速排序 快速搞定》），也可以直接使用VC库中的快速排序函数（请参阅《使用VC库函数中的快速排序函数》）。下面列出完整代码：

```
#include<iostream>  
#include<algorithm>  
#include<cstring>  
using namespace std;  
#include<assert.h>  
    
//反转区间  
void Reverse(char* pBegin , char* pEnd)  
{  
    while(pBegin < pEnd)  
        swap(*pBegin++ , *pEnd–);  
}  
//下一个排列  
bool Next_permutation(char a[])  
{  
    assert(a);  
    char *p , *q , *pFind;  
    char *pEnd = a + strlen(a) - 1;  
    if(a == pEnd)  
        return false;  
    p = pEnd;  
    while(p != a)  
    {  
        q = p;  
        p–;  
        if(*p < *q)  //找降序的相邻2数,前一个数即替换数    
        {  
                //从后向前找比替换点大的第一个数  
            pFind = pEnd;  
            while(*pFind < *p)  
                –pFind;  
            swap(*p , *pFind);  
            //替换点后的数全部反转  
            Reverse(q , pEnd);  
            return true;  
        }  
    }  
    Reverse(a , pEnd);   //如果没有下一个排列,全部反转后返回false     
    return false;  
}  
    
int cmp(const void *a,const void *b)  
{  
    return int(*(char *)a - *(char *)b);  
}
```

至此我们已经运用了递归与非递归的方法解决了全排列问题，总结一下就是：

- 1、全排列就是从第一个数字起每个数分别与它后面的数字交换。

- 2、去重的全排列就是从第一个数字起每个数分别与它后面非重复出现的数字交换。

- 3、全排列的非递归就是由后向前找替换数和替换点，然后由后向前找第一个比替换数大的数与替换数交换，最后颠倒替换点后的所有数据。

## 二、字典序法

### 1. 介绍

字典序法的核心思想即 **从字典序最小的排列出发，每次找到当前排列的下一个较大的字典序排列，直到找到最大的字典序排列，至此要求的全排列已经找到**

> 字典序即是对各排列按照字典的顺序进行排列，如对于串 "123456" ，按照字典串生成的序列是 "123456"->"123465"->...->"654312"->"654321"，
按照字典序法的要求，我们要从 "123456" 出发，依次找到下一个字典序的排列，直到找到最后一个字典序排列 "654321"

所以，该算法的关键是 **给定一个当前排列，如何找到下一个字典序的排列？**

### 2. 算法核心

遵循以下步骤，即可找到当前排列的下一个字典序排列(以 "158476531" 为例，其下一个字典序排列为 "158513467" )：

- 1. 从当前排列 "158476531" 的右端开始，找到第一个比其右边数字小的数字 "4"（找最后一个正序）
- 2. 在 "4" 的右边数字中，找出所有比 "4" 大的数字中最小的数字 "5"
- 3. 交换 "4" 和 "5" 的位置，此时生成的排列为 "158576431"
- 4. 再将现在序列中 "5" 的位置之后的数字 "76431" 进行倒转，生成下一个字典序列 "158513467"

<div align="center"><img src="img/dicseq.gif"></img></div>

### 3. 例子：

`nextPermutation` 用于求给定排列的下一个字典序排列，如果给定的已经是最大字典序列，则返回最小字典序列

```
//前提：vector中的元素必须已经排好序
void nextPermutation(vector<int>& arr) {
    //1.求最后一个正序
    int i = arr.size() - 2;
    while (i >= 0 && arr[i] >= arr[i+1]) {
        i--;
    }
    if (i >= 0) {
        //2.找到比pos大的数字中最小的数字
        int j = arr.size() - 1;
        while (j >= 0&&  arr[j] <= arr[i]) {
            j--;
        }
        swap(arr[i], arr[j]);
    }
    reverse(arr, i+1);
}
void reverse(vector<int>& arr, int beg) {
    int left = beg;
    int right = arr.size()-1;
    while (left < right) {
        swap(arr[left], arr[right]);
        left++;
        right--;
    }
}
```

其实，STL 中已经有[std::permutation](https://www.geeksforgeeks.org/stdnext_permutation-prev_permutation-c/)库函数，平时可以直接用

### 4. 相关题目：

- [LeetCode：下一个排列](https://leetcode-cn.com/problems/next-permutation/)

## 三、插入法

## 四、邻位对换法

## 五、递增进位制法

## 六、递减进位制法
