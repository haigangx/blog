# 模运算


## 运算规则

    (a + b) % p = (a % p + b % p) % p  
    (a - b) % p = (a % p - b % p) % p  
    (a * b) % p = (a % p * b % p) % p  
    a ^ b % p = ((a % p)^b) % p


## 应用

### 1.判断奇偶数
```
bool IsEven( int n )
{
    return (n % 2 == 0);
}
```

### 2.判断素数

```
bool IsPrime( unsigned int n )
{
    unsigned maxFactor = sqrt( n );
    for ( unsigned int i = 2; i < n; i++ )
    {
        if ( n % i == 0 )
            return false;
    }
    return true;
}

```

### 3.最大公约数

使用欧几里德算法(辗转相除法)，原理：gcd(a, b) = gcd(b, a % b)

```
int Gcd( int a, int b )
{
    if ( b == 0 )
        return a;
    return gcd( b, a % b );
}
```


### 4.水仙花数
水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身（例如：$1^3 + 5^3+ 3^3 = 153$）

```
//求三位水仙花数：
int NarcissisticNumber()
{
    for ( int i = 100; i < 1000; i++ )
    {
        //按照水仙花的定义计算
        if ( pow(i%10, 3) + pow(i/10%10, 3) + pow(i/100%10, 3) == i )
            cout << i << endl;
    }
}
```

水仙花数其实是三位自幂数(自恋数)，求任意位数自幂数：
```
//任意位数水仙花数
int NarcissisticNumber( int digitsNum )
{
    long tempSum = 0, tempNum = 0;
    long beginN = pow( 10, digitsNum-1 );
    long endN = pow( 10, digitsNum );
    for ( long i = beginN; i < endN; i++ )
    {
        //每个digitsNum位数都使用定义判断
        for ( int j = 0; j < digitsNum; j++ )
        {
            tempNum = pow( 10, j );
            tempNum = i / tempNum;
            tempNum = tempNum % 10;
            tempNum = pow( tempNum, digitsNum );
            tempSum += tempNum;
        }
        if ( tempSum == i )
            cout << tempSum << endl;
    }
    return 0;
}
```

### 5.横幂问题

利用模运算的运算规则，简化某些运算，例如

[leetcode](https://leetcode-cn.com/problems/super-pow/)372.你的任务是计算$a^b$对1337取模，a是一个正整数，b是一个非常大的正整数且会以数组形式给出。

互质

基本概念：
* 欧拉定理：
 
    a,n为正整数，且a,n互质，那么$a^{\varphi(x)}\equiv1(mod\ n)$
 
* 互质(互素)：
* 欧拉函数：

    欧拉函数f(n)(n ( N<sup>*</sup>)是小于等于n的正整数中与n互质的数的个数
    
* 欧拉-费马降幂：

    a<sup>x</sup> = a<sup>(x%f()</sup>

* 快速幂：





### 6.孙子问题(中国剩余定理)

《孙子算经》上有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题被称为“孙子问题”，该问题的一般解法被称为“中国剩余定理”，具体解法分三步：
* 1.找出三个数：从3和5的公倍数中找出被7除余1的最小数15，从3和7的公倍数中找出被5除1的最小数21，最后从5和7的最小公倍数中找出除3余1的最小数70.
* 2.用15乘以2（2为最终结果除以7的余数），用21乘以3（3为最终结果除以5的余数），同理，用70乘以2（2为最终结果除以3的余数），然后把三个乘积相加`15*2+21*3+70*2`得到和233.
* 3.用233除以3,5,7三个数的最小公倍数105，得到余数23，即`233%105=23`。这个余数23就是符合条件的最小数。

具体的解法推导过程参考博文：[中国剩余定理](https://www.cnblogs.com/MashiroSky/p/5918158.html)

根据剩余定理，把此种解法推广到有n（n为自然数）个除数对应n个余数，求最小被除数的情况。输入n个除数（除数不能互相整除）和对应的余数，计算机将输出最小被除数。

```
/*
 * 函数名：ResidueTheorem
 * 函数功能：运用剩余定理，解决推广了的孙子问题，给定n个除数（除数不能互相整除）和对应余数，返回最小被除数
 * 输入值：devisor,存储了n个除数的数组；remainder,存储了n个余数的数组；length，这两个数组的长度
 * 返回值：最小被除数
 */
unsigned ResidueTheorem( const unsigned devisor[], const unsigned remainder[], int length )
{
    unsigned product = 1;    //所有除数的乘积
    
    for ( int i = 0; i < length; i++ )
    {
        product *= devisor[i];
    }
    
    //公倍数数组，表示除该元素(除数)之外其他除数的公倍数
    unsigned *commonUmltiple = new unsigned[length];
    for ( int i = 0; i < length; i++ )
    {
        commonUmltiple[i] = product / devisor[i];
    }
    
    //被除数，函数将返回的值
    unsigned dividend = 0;
    //计算被除数，但此时得到的不是最小被除数
    for ( int i = 0; i < length; i++ )
    {
        //按照剩余利落计算合适的公倍数，使得tempMul%devisor[i]==1
        unsigned tempMul = commonMultiple[i];
        while ( tempMul % devisor[i] != 1 )
        {
            tempMul += commonMultiple[i];
        }
        //用本除数得到的余数乘以其他除数的公倍数
        dividend += tempMul * remainder[i];
    }
    delete[] comonMultiple;
    //返回最小被除数
    return ( dividend % product );
}
```

### 7.凯撒密码





[^互质]：公约数只有1的两个整数，叫做互质整数
