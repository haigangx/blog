### 低位优先的字符串排序

低位优先的字符串排序： 从右向左检查字符串中的字符，分别按每一位上的字符对字符串排序，类似于基数排序，这种方法一般称为 *低位优先(LSD)* 的字符串排序，低位优先的字符串排序适合于键长度都相同的字符串排序

以案例说明：

> 假设我们需要对一堆车牌号进行排序，车牌号由数字和字母组成，一般情况下，它们的长度都相同（类似的定长字符串还有电话号码、银行账户、IP地址等）

低位优先字符串排序很适合上述排序：

低位优先字符串排序的意义在于，它是一种适用于一般应用的*线性时间排序算法*：无论要排序的字符串数量N多大，它都只需要遍历W(每个字符串长度)次数据

![低位优先的字符串排序](img/lsd_sort.png)

将上图中的字符串从右到左的顺序依次按位进行排序，每次排序可以使用键索引计数法，键索引计数法是一种稳定的排序方法


```
//将每个元素长度均为w的字符串数组排序按低位优先排序
void LSD_sort(vector<string> str_vec, int w)
{
    int len = str_vec.size();
    int R = 256;
    vector<string> sort_str_vec(len);

    for (int i = w-1; i >= 0; i--)
    {
        int count[R+1] = {0};
        for (int j = 0; j < len; j++)
        {
            count[str_vec[j].at(i)]++;
        }
        for (int j = 1; j < R+1; j++)
        {
            count[j] = count[j] + count[j-1];
        }
        for (int j = 0; j < len; j++)
        {
            sort_str_vec[count[str_vec[j].at(i)]++] = str_vec[i];
        }
        for (int j = 0; j <len; j++)
        {
            str_vec[j] = sort_str_vec[j];
        }
    }
}
```

