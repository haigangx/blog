### 三向字符串快速排序

高位优先排序对包含大量重复键的字符串进行排序时，效率十分低下。三向字符串快速排序可以很好的解决这个问题

#### 核心思想

利用分治的思想，通过中间字符串每次将字符串数组划分为三个小组

再递归地对小组进行同样的处理，直到走到字符串末尾，最后形成的字符串数组自然有序

#### 具体做法

- 1. 用一个字符作为中间字符(本片文章中默认字符串的第一个字符)，比它大的移到字符串数组末尾，比它小的移到它前面，这样遍历完一遍后会形成三个小组，里面的字符串开头字母分别为：小于中间字符、等于中间字符、大于中间字符
- 2. 对分类的三个字符串数组逐一进行步骤1直到字符串中的字符全部便利。最后形成的字符串自然有序

#### 实例演示

![三向字符串快速排序](img/quick_three_sort_string.png)

#### 与LSD、MSD的对比

- LSD中没有分组的概念，单纯从右到左对每个字符排序
- MSD加入了分组的概念，但对于每个分组也是从头到尾，由于每次排序都要创建辅助数组，在数组较长时将会用到很大的空间
- 三向字符串快速排序与两者不同的是不用额外申请空间，且对于存在大量相同前缀的字符串数组，它也能很好的处理

#### 完整代码

```
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
 
using namespace std;
 
void swap(vector<string>& a, int m, int n)
{
    string temp = a[m];
    a[m] = a[n];
    a[n] = temp;
}
 
int charAt(const string& str, int d)
{
    if ( d < str.size() )
        return str[d];
    else 
        return -1;
}
 
void quick_3_string(vector<string>& sVec, int lo, int hi, int d)
{
    if (hi<=lo)
        return;
    int lt = lo, gt = hi;
    int v = charAt(sVec[lo], d);
    int i = lo + 1;
    while (i<=gt)
    {
        int t =  charAt(sVec[i], d);
        if (t < v) swap(sVec, lt++, i++);
        else if ( t > v) swap(sVec, i, gt--);
        else i++;
    }
 
    quick_3_string(sVec, lo, lt-1, d);
    if (v >=0 )
        quick_3_string(sVec, lt, gt, d+1);
    quick_3_string(sVec, gt+1, hi, d);
}
```
