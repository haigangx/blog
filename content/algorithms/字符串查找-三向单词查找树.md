# 三向单词查找树

在 R 向单词查找树中，每生成一个新结点，就会为该结点生成 R 个子节点，然后很多结点都是空的，因此，为了避免 R 向单词查找树的过度空间消耗，可以使用另一种数据结构的表示方法——三向单词查找树

三向单词查找树中：

- 每个结点包含一个字符，一个值，三个子节点
- 三个子节点分别对应着当前结点中，结点字母小于，等于，或大于当前结点的所有键
- 字符显式地保存在结点中

下图是R向单词查找树和三向单词查找树的区别：上面是R向单词查找树，下面是三向单词查找树

![三向单词查找树和R向单词查找树区别](img/R_Trie_3_Trie.png)

##### 代码实现

- 查找：在三向单词查找树的查找操作中，我们先对比根节点，如果键的首字母较小，则在左侧子树中查找；如果键首字母较大，则在右子树中查找。递归进行该算法，直到遇到空节点或键结束
- 插入：进行插入操作时，在查找的基础上，每当遇到一个空连接，则新建一个结点并保存字符

```
#pragma once
#include <memory>
#include <string>

class TST
{
private:
    class Node
    {
    private:
        std::unique_ptr<int> c;
        bool end;
        std::unique_ptr<Node> left;
        std::unique_ptr<Node> mid;
        std::unique_ptr<Node> right;
    private:
        void put(const std::string& s, const int& pos)
        {
            if (pos == s.length())
                return;
            if (c == nullptr)
            {
                c = std::move(std::unique_ptr<int>(new int(s[pos])));
                if (pos == s.length() - 1)
                {
                    end = true;
                    return;
                }
                if (mid == nullptr)
                    mid = std::move(std::unique_ptr<Node>(new Node));
                mid->put(s, pos + 1);
                return;
            }
            int temp = *c;
            if (s[pos] < temp)
            {
                if (left == nullptr)
                    left = std::move(std::unique_ptr<Node>(new Node));
                left->put(s, pos);
            }
            else if (s[pos] > temp)
            {
                if (right == nullptr)
                    right = std::move(std::unique_ptr<Node>(new Node));
                right->put(s, pos);
            }
            else
            {
                if (mid == nullptr)
                    mid = std::move(std::unique_ptr<Node>(new Node));
                mid->put(s, pos);
            }
        }
        bool find(const std::string& s, const int& pos)
        {
            if (pos >= s.length())
                return false;
            if (c == nullptr)
                return false;
            if (end == true && pos == s.length() - 1 && *c == s[pos])
                return true;
            else if (end != true && pos == s.length() - 1 && *c == s[pos] && mid != nullptr)
                return mid->find(s, pos);
            else
            {
                int temp = *c;
                if (s[pos] < temp && left != nullptr)
                    return left->find(s, pos);
                else if (s[pos] > temp && right != nullptr)
                    return right->find(s, pos);
                else if (s[pos] == temp && mid != nullptr)
                    return mid->find(s, pos + 1);
            }
            return false;
        }
    public:
        Node()
            :c(nullptr),left(nullptr),mid(nullptr),right(nullptr),end(false)
        {

        }
        void put(const std::string& s)
        {
            put(s, 0);
        }
        bool find(const std::string& s)
        {
            return find(s, 0);
        }
    };
private:
    std::unique_ptr<Node> root;
public:
    TST():root(new Node)
    {

    }
public:
    void put(const std::string& s)
    {
        root->put(s);
    }
    bool find(const std::string& s)
    {
        return root->find(s);
    }
};
```

