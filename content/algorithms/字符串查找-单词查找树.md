# 单词查找树

<!-- TOC -->

- [基本思想](#基本思想)
- [Trie树实现](#trie树实现)

<!-- /TOC -->

单词查找树即字典树(Trie树)，是一种哈希树的变种。典型应用是用于统计、排序和保存大量的字符串(但不仅限于字符串)，所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高

## 基本思想

下图是由单词at, bee, ben, bt, q组成的Trie树

![单词查找树实例](img/trie_tree_example1.jpg)

可以看出，trie树中每个字母的父节点就是它的前一个字母

Trie树的三个性质：

- 1. 根节点不包含字符，除根节点外的每一个节点都只包含一个字符
- 2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串
- 3. 每个节点的所有子节点包含的字符都不相同

这样，对于长为l的单词来说，无论插入还是查询都是O(l)的事件复杂度

Trie树的特点：

- 空间换时间
    - 每个节点都有至少26个子节点(英文字母)
    - 插入、查询时间复杂度为O(len)
    - 排序按照Trie树先序遍历
- 节约空间
    - 保存大量单词的时候，相同前缀的空间公用。大部分字符串具有相同的前缀，即公共前缀
    - 每个节点，对应一项前缀，叶子节点对应最长前缀，即单词本身

## Trie树实现

```
struct Trie     //定义Trie树节点结构体
{
    int value;  //节点的值，表示该单词出现的次数
    Trie *child[26];    //指向的子节点的指针
    Trie()
    {
        value = 0;
        memset(child, NULL, sizeof(child));
    }
}*root;     //根节点指针

/* 插入过程：
 * 1.从根节点开始，按照字母对应节点不断向下
 * 2.直到单词结束，在该节点上记录单词信息
 */
void Insert(char str[])     //插入字符串str
{
    Trie *x = root;     //从根节点开始
    for (int i = 0; str[i]; i++)    //逐个插入
    {
        int d = str[i] - 'a';
        //若子节点不存在，则new出对应节点
        if (x->child[d] == NULL)
            x->child[d] = new Trie;
        x = x->child[d];    //转成对应子树
    }
    x->value++;     //表示该单词出现次数
}

/* 查找过程
 * 1.从根节点开始搜索
 * 2.得到第一个字母节点后，转到对应子树
 * 3.在相应子树继续搜索下一个字母
 * 4.重复上述操作，直到到此结束，读取节点信息
 */
int Search(char str[])      //查找字符串str
{
    Trie *x = root;     //从根节点开始
    for (int i = 0; str[i]; i++)
    {
        int d = str[i] - 'a';
        if (x->child[d] == NULL)    //查找失败，直接退出
            return 0;
        x = x->child[d];    //转成对应子树
    }
    return x->value;    //查找成功，返回节点的值
}


void Deal(Trie *x)  //释放x为根的子树
{
    if (x == NULL)
        return;
    for (int i = 0; i < 26; i++)    //释放x的所有子节点
    {
        if (x->child[i] != NULL)
            Deal(x->child[i]);
    }
    delete x;   //释放x节点空间
}
```

