# 键索引计数法

对键长度较小的字符串排序中，一般使用 *键索引计数法* ，其过程类似于计数排序，在上述两种字符串排序方法的过程中，可以在按位排序时使用这种方法辅助排序

键索引计数法使用计数排序的思想对键索引进行排序来完成键值对的排序

![键索引计数法排序](img/key_count_sort.png)

## 过程

排序的步骤：

- 使用int数组conut[]计算每个键出现的频率。如果键为r，则将count[r+1]加1(这样的话，count[r+1]中保存r键的出现频率，count[r+1]之前所有元素的和是r键在排序结果中的位置)
- 将count[]转化为每个键在排序结果中的起始索引位置。对于键值r来说，其排序后的起始索引位置为所有键值小于r的键的频率之和，
- 将所有键值对排序到辅助数据aux[]中，每排序好一个键值对，需要将count[]中对应元素的值加1，以保证count[r]总是下一个键为r的元素在aux[]中的索引位置

键索引计数法是一种对于小整数键排序非常有用却常常被忽略的排序方法


## 代码：

```
#include <utility>
#include <string>
#include <vector>

using namespace std;

const int COUNT_SIZE = 11;

void key_count_sort(vector<pair<int, string> >& std_table)
{
    int count[COUNT_SIZE] = {0};
    //第一步
    for (auto v : std_table)
    {
        count[v.first+1]++;
    }
    //第二步
    for (int i = 1; i < COUNT_SIZE; i++)
    {
        count[i] = count[i] + count[i-1];
    }
    //第三步
    vector<pair<int, string> > std_sort_table(std_table.size());
    for (auto v : std_table)
    {
        std_sort_table[count[v.first]] = v;
        count[v.first]++;
    }
    //回写
    for (int i = 0; i < std_table.size(); ++i)
    {
        std_table[i] = std_sort_table[i];
    }
}

```
