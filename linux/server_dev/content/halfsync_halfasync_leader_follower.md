# 两种高效的并发模式

两种高效的并发模式：
计算密集型程序：并发编程没有优势，反而由于任务的切换使效率降低
I/O密集型程序：在CPU阻塞于I/O操作时转移到其他线程使得CPU利用率显著提高
服务器的两种主要并发编程模式：半同步半异步(half-sync/half-async)模式和领导者/追随者(Leader/Follower)模式

图

## 半同步/半异步模式

在I/O模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种I/O事件(就绪或完成事件)，以及该由谁来完成I/O读写(应用程序或内核)

并发模式中，“同步”是指程序完全按照代码序列的顺序执行，“异步”指的是程序的执行需要由系统事件来驱动,例如终端、信号等

下图分别展示了同步读操作和异步读操作

按照同步方式运行的线程成为同步线程，按照异步方式运行的线程称为异步线程。

异步线程：执行效率高，实时性强，编写相对复杂，难于调试和拓展
同步线程：效率较低，实时性较差，但逻辑简单易编写
半同步半异步：既拥有较好的实时性，又能同时处理多个客户请求
在半同步半异步模型中，同步线程用于处理客户逻辑，相当于逻辑单元；异步线程用于处理IO事件，相当于IO处理单元
过程：异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中，请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。具体选择哪个工作线程来为新的客户请求服务取决于请求队列的设计(比如最简单的轮流选取工作线程的Round Robin算法，或条件变量，或信号量来随机选择)
下图展示了半同步半异步的工作流程：


1.1 半同步/半反应堆(half-sync/half-reactive)模式
半同步半反应堆模式是半同步半异步模式的一种变形，主要过程如下：
过程：异步线程只有一个，由主线程来充当。它负责监听所有socket上的事件。如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接受之以得到新的连接socket，然后往epoll内核时间表中注册该socket上的读写事件。如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接socket插入请求队列中，所有工作线程都睡眠在请求队列上，当有任务到来时，它们将通过竞争(比如申请互斥锁)获得任务的接管权，这种竞争机制使得只有空闲的工作线程才有机会处理新任务，这是很合理的。

上图中，主线程插入请求队列中的任务是就绪的连接socket。这说明该图所示的半同步/半反应堆模式采用的事件处理模式是Reactor模式：他要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。这就是该模式的名称中"half-reactive"的含义。实际上，半同步/半反应堆模式也可以使用模拟的Proactor事件处理模式，即由主线程来完成数据的读写。在这种情况下，主线程一般会将应用程序数据、任务类型等信息封装为一个任务对象，然后将其插入请求队列。工作流程从请求队列中取得任务对象之后，即可直接处理之，而无需执行读写操作。

半同步/半反应堆模式有如下缺点：
1、主线程和工作线程共享请求队列。主线程往请求队列中添加任务，或者工作线程从请求队列中取出任务，都需要对请求队列加锁保护，从而白白耗费CPU时间
2、每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度将会越来越慢，如果通过增加工作线程来解决这一问题，则工作线程的切换也将耗费大量CPU事件。

下面有一种相对高效的半同步/半异步模式，它的每个工作线程都能同时处理多个客户连接：
下图展示了其工作流程：

过程：主线程只管理监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I/O操作都由被选中的工作流程来处理，知道客户关闭连接。主线程向工作线程派发socket的最简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，则把该新socket上的读写事件注册到自己的epoll内核事件表中。
由此可见，每个线程(主线程和工作线程)都维持自己的事件循环，它们各自独立地监听不同的事件，因此在这种高效的半同步/半异步模式中，每个线程都工作在异步模式，所以他们并非严格意义上的半同步/半异步模式。


## 领导者/追随者模式

领导者/追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。在任意时间点，程序都仅有一个领导者线程，它负责监听I/O事件。而其他线程则都是追随者，他们休眠在线程池中等待成为新的领导者。当前的领导者如果检测到I/O事件，首先要从线程池中推选出来新的领导者线程，然后处理I/O事件。此时，新的领导者等待新的I/O事件，而原来的领导者则处理I/O事件，二者实现了并发。
领导者/追随者模式包含一下几个组件：句柄集(HandleSet)、线程集(ThreadSet)、事件处理器(EventHandler)和具体的事件处理器(ConcreteEventHandler)。他们的关系如下图所示:

1、句柄集：
句柄表示I/O资源，Linux下为文件描述符。句柄集管理众多文件描述符，并将就绪的事件通知到领导者线程。领导者则调用绑定到句柄Handle上的事件处理器来处理事件。通过句柄集中的register_handler方法为Handler绑定事件处理器

2、线程集:
所有工作线程(领导者线程和追随者线程)的管理者，负责各线程间的同步，以及新领导者线程的推选。线程集中的线程有三种状态：
(1)Leader:领导者身份，负责等待句柄集上的I/O事件
(2)Processing:正在处理事件，领导者检测到I/O事件后，将转移到Processing状态来处理该事件，并调用promote_new_leader方法推选新的领导者；也可以制定其他追随者来处理事件(Event Handoff),此时领导者的地位不变。当处于Processing状态的线程处理完事件之后，如果当前线程集中没有领导这，则它将成为新的领导者，否则它就直接转变为追随者
(3)Follower:线程当前处于追随者身份，通过调用线程集的join方法等待成为新的领导者，也可能被当前的领导者指定来处理新的任务
下图展示这三种状态之间的转换关系:

需要注意的是，领导者线程推选新的领导者和追随者等待成为新领导者这两个操作都将修改进程集，因此线程集提供一个成员Synchronizer来同步这两个操作，以避免竞态条件

3、事件处理器和具体的事件处理器：
事件处理器通常包含一个或多个回调函数handle_event。事件处理器与句柄绑定，领导者处理句柄上到达的事件时调用该事件处理器，一系列事件处理器通常继承于一个事件处理器基类，他们通过实现基类的handle_event方法来处理特定任务
领导者/追随者模式的工作流程如下图：

优点：领导者线程自己监听I/O事件并处理客户请求，所有不需要线程间进行通信，无需像半同步半异步那样在线程之间同步对请求队列的访问
缺点：仅支持一个事件源集合，因此无法实现像高效的半同步半异步模式那样每个工作线程管理多个客户连接
